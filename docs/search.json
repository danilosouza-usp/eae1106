[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EAE1106 - Métodos Computacionais para Economia",
    "section": "",
    "text": "Bem-vindo\nEste é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "index.html#agradecimentos-e-reprodução",
    "href": "index.html#agradecimentos-e-reprodução",
    "title": "EAE1106 - Métodos Computacionais para Economia",
    "section": "Agradecimentos e reprodução",
    "text": "Agradecimentos e reprodução\nEsse material deve muito a X, Y e Z\nEsse material foi construído bla bla bla. Qualquer erro é de responsabilidade exclusiva do autor. Todo e qualquer feedback é muito bem-vindo.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introdução",
    "section": "",
    "text": "Este é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Introdução"
    ]
  },
  {
    "objectID": "alfabetizacao.html",
    "href": "alfabetizacao.html",
    "title": "Alfabetização computacional e lógica básica",
    "section": "",
    "text": "Este é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Alfabetização computacional e lógica básica"
    ]
  },
  {
    "objectID": "fundamentos.html",
    "href": "fundamentos.html",
    "title": "1  Fundamentos de computação",
    "section": "",
    "text": "1.1 O que é um computador?\nIn summary, this book has no content whatsoever.\nUm computador realiza duas coisas e apenas duas coisas: faz operações e guarda de forma eficiente o resultado dessas operações. No entanto, ao fazer essas duas coisas de forma extremamente eficiente essa máquina chamada computador nos permite receber, armazenar, processar e transmitir informações. Em essência, o computador nos serve ao propósito de resolução de problemas. Isso significa que, através de uma linguagem formal (especificamente operações de computação), podemos formular problemas e programar meios de resolver de forma automatizada tais problemas. No fim das contas, programar é o ato de criar programas, isto é, estabelecer uma sequência de instruções em linguagem formal que especifica como executar uma determinada operação no computador.\nMas antes de avançar na ideia de programa e algoritmos, quais são as características de um computador como o conhecemos?",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentos de computação</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#o-que-é-um-computador",
    "href": "fundamentos.html#o-que-é-um-computador",
    "title": "1  Fundamentos de computação",
    "section": "",
    "text": "1.1.1 Sistema computacional\nUm sistema computacional é resultado da integração de componentes atuando como uma entidade, com o propósito de processar dados, isto é, realizar algum tipo de operação lógica envolvendo os dados, de modo a produzir diferentes níveis de informações. Componentes:\n\nHardware: componente física de um sistema de computação, isto é, todos os equipamentos utilizados pelo usuário nas ações de entrada, processamento, armazenamento e saída de dados.\nSoftware: componente lógica de um sistema de computação, isto é, séries de instruções que fazem o computador funcionar (programas de computador)\n\nE por fim o componente humano do sistema, as pessoas, que utilizam o computador basicamente como ferramenta para atingir determinado fim, para resolver problemas.\n\n\n1.1.2 Arquitetura de um computador\nOs computadores, como os conhecemos hoje, são estruturados em cima da lógica proposta inicialmente por John Von Neumann, matemático húngaro que viveu durante a primeira metade do século XX e que contribuiu imensamente em várias dimensões das ciências. Embora tenhamos hoje uma complexidade maior nos elementos que compõe a arquitetura de um computador, a estrutura básica por trás dos computadores mais modernos continua sendo aquela proposta por Von Neumann. Essa arquitetura pode ser representado pelo diagrama abaixo:\n\nEssencialmente, o hadware que compõe as partes da arquitetura de um computador podem ser dividas em 3 partes:\n\nDispositivos de entrada e saída: é através deles que o usuário dialoga com a máquina. Através do teclado e mouse, por exemplo, o usuário fornece informações ao computador a partir das quais processos serão realizados e seus resultados serão percebidos pelos dispositivos de saída (monitor e impressora, por exemplo).\nUnidade central de processamento (CPU): é o cérebro do sistema computacional, é nele que serão executados cálculos e instruções lógicas dos usuários.\nMemória: aqui são armazenados os resultados dos cálculos, dados e instruções.\n\n\n\n1.1.3 Capacidade de armazenamento\n\nKilobyte: 1024 (2^10) bytes.\n\nCapacidade de memória dos computadores pessoais muito antigos.\n\n\nMegabyte: aproximadamente, um milhão (2^20) de bytes.\n\nMemória de computadores pessoais antigos.\n\n\nGigabyte: aproximadamente, um bilhão (2^30) de bytes.\n\nDispositivos de armazenamento (discos rígidos), especialmente SSD\n\n\nTerabyte: aproximadamente, um trilhão (2^40) de bytes.\n\nDispositivos de armazenamento para sistemas muito grandes e servidores.\n\n\n\n\n\n1.1.4 Como computadores armazenam números\nPara entender a diferença entre computação de precisão simples e de precisão dupla, é importante entender o papel da precisão na ciência da computação. Imagine realizar um cálculo usando um número irracional (como \\(\\pi\\)) e incluindo apenas dois dígitos à direita do ponto decimal (3.14). Você obteria um resultado mais preciso se fizesse o cálculo incluindo dez dígitos à direita do ponto decimal (3,1415926535).\nPara computadores, esse nível de precisão é chamado de precisão e é medido em dígitos binários (bits) em vez de casas decimais. Quanto mais bits usados, maior a precisão. A representação de grandes números em binários de computador requer um padrão para garantir que não haja grandes discrepâncias nos cálculos. Assim, o Instituto de Engenheiros Elétricos e Eletrônicos (IEEE) desenvolveu o Padrão IEEE para Aritmética de Ponto Flutuante (IEEE 754).\nEm geral, um número será representado de forma aproximada com um número fixo de números significantes e escalonado usando um expoente em uma base (usualmente dois, ou 10 ou 16). Esses números possuem a seguinte forma:\n\\[ S \\times B^e \\]\nEm que \\(S\\) é o significando, \\(B\\) é um número inteiro maior ou igual a dois, e \\(e\\) um expoente, um número inteiro. Por exemplo: \\(1.2345=12345 \\times 10^{-4}\\). O termo Ponto Flutuante se refere ao fato que o ponto decimal (também chamado de ponto binário) pode flutuar; ou seja, pode ser colocado em qualquer lugar em relação aos dígitos significantes do número. Esta posição é indicada pelo expoente, e a representação em ponto flutuante de um número pode ser pensada como uma forma de notação científica.\nA precisão nessa representação de ponto flutuante é dada pela quantidade de bits dedicado ao armazenamento do significando e do expoente – quanto maior o significando, mais precisa é a representação (menor é o espaço entre dois números), e quanto maior o expoente, mais alto é o maior valor que pode ser representado.\nExistem três componentes do IEEE 754:\n\nO sinal - 0 representa um número positivo; 1 representa um número negativo.\nO expoente - O expoente é usado para representar expoentes positivos e negativos.\nO significando - Também conhecida como mantissa, a mantissa representa os bits de precisão do número.\n\nUsando esses componentes, o IEEE 754 representa números de ponto flutuante de duas maneiras: formato de precisão simples e formato de precisão dupla. Embora ainda existam várias maneiras de representar números de ponto flutuante, o IEEE 754 é o mais comum porque geralmente é a representação mais eficiente de valores numéricos.\n\n\n1.1.5 Formato de ponto flutuante de precisão simples\nO formato de ponto flutuante de precisão simples usa 32 bits (um bit pro sinal, 8 pro expoente e 24 pro significando) de memória do computador e pode representar uma ampla gama de valores numéricos. Muitas vezes referido como FP32, esse formato é melhor usado para cálculos que não sofrem um pouco de aproximação.\n\n\n1.1.6 Formato de ponto flutuante de precisão dupla\nO formato de ponto flutuante de precisão dupla, por outro lado, ocupa 64 bits (um bit pro sinal, 11 pro expoente e 52 pro significando) da memória do computador e é muito mais preciso do que o formato de precisão simples. Esse formato é frequentemente chamado de FP64 e usado para representar valores que exigem um intervalo maior ou um cálculo mais preciso.\nEmbora a precisão dupla permita mais precisão, ela também requer mais recursos computacionais, armazenamento de memória e transferência de dados. O custo de usar esse formato nem sempre faz sentido para todos os cálculos.\n\n\n\n1.1.7 Mas qual a importância disso tudo?\nSaber como os computadores armazenam números, ou qual a importância da memória no processo de fornecimento de parâmetros de entrada em busca de uma saída específica, nos ajuda enormemente a entender porque, por exemplo, um sistema 32 bits só é capaz de nos fornecer 4GB de memória RAM para armazenamento de cálculos e operações ou mesmo porque podemos ter dificuldade ao tentar abrir no nosso computador local um arquivo com alguns milhões de linhas.\nÉ importante ter o conhecimento mínimo de como funciona um computador e como os programas que iremos utilizar interagem com as partes da arquitetura do computador para entendermos o que está ocorrendo atrás das cortinas. Dessa forma, podemos nos concentrar exclusivamente no que nos interessa, isto é, utilizar o computador como ferramenta para resolver problemas e não como um fim em si (afinal estamos em um curso de economia e não de ciência da computação). Para tal precisamos de alguma linguagem lógica/formal que nos permita enviar as intruções para o computador e obter as respostas desejadas. Como já deve ter ficado claro, nesse curso trabalharemos com a linguagem Python.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentos de computação</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#linguagens-de-programação",
    "href": "fundamentos.html#linguagens-de-programação",
    "title": "1  Fundamentos de computação",
    "section": "1.2 Linguagens de programação",
    "text": "1.2 Linguagens de programação\nAs linguagens naturais são os idiomas que as pessoas falam, como inglês, espanhol e francês. Elas não foram criadas pelas pessoas (embora as pessoas tentem impor certa ordem a elas); desenvolveram-se naturalmente. As linguagens formais são linguagens criadas pelas pessoas para aplicações específicas. Por exemplo, a notação que os matemáticos usam é uma linguagem formal especialmente boa para denotar relações entre números e símbolos. Os químicos usam uma linguagem formal para representar a estrutura química de moléculas. E o mais importante:\nAs linguagens de programação são idiomas formais criados para expressar operações de computação.\nAs linguagens formais geralmente têm regras de sintaxe estritas que governam a estrutura de declarações. Por exemplo, na matemática a declaração $3 + 3 = $6 tem uma sintaxe correta, mas não \\(3 + = 3\\$6\\). Na química, H2O é uma fórmula sintaticamente correta, mas 2Zz não é. As regras de sintaxe vêm em duas categorias relativas a símbolos e estrutura. Os símbolos são os elementos básicos da linguagem, como palavras, números e elementos químicos. Um dos problemas com \\(3 + = 3\\$6\\) é que o ‘$’ não é um símbolo legítimo na matemática (pelo menos até onde eu sei). De forma similar, 2Zz não é legítimo porque não há nenhum elemento com a abreviatura Zz.\nO segundo tipo de regra de sintaxe refere-se ao modo no qual os símbolos são combinados. A equação 3 + = 3 não é legítima porque, embora + e = sejam símbolos legítimos, não se pode ter um na sequência do outro. De forma similar, em uma fórmula química o subscrito vem depois do nome de elemento, não antes.\nEsta é um@ frase bem estruturada em portuguê$, mas com s*mbolos inválidos.\nAo ler uma frase em português ou uma declaração em uma linguagem formal, é preciso compreender a estrutura (embora em uma linguagem natural você faça isto de forma subconsciente). Este processo é chamado de análise. Embora as linguagens formais e naturais tenham muitas características em comum – símbolos, estrutura e sintaxe – há algumas diferenças:\n\nAmbiguidade: as linguagens naturais são cheias de ambiguidade e as pessoas lidam com isso usando pistas contextuais e outras informações. As linguagens formais são criadas para ser quase ou completamente inequívocas, ou seja, qualquer afirmação tem exatamente um significado, independentemente do contexto\nRedundância: para compensar a ambiguidade e reduzir equívocos, as linguagens naturais usam muita redundância. Por causa disso, muitas vezes são verborrágicas. As linguagens formais são menos redundantes e mais concisas.\nLiteralidade: as linguagens naturais são cheias de expressões e metáforas. Se eu digo “caiu a ficha”, provavelmente não há ficha nenhuma na história, nem nada que tenha caído (esta é uma expressão para dizer que alguém entendeu algo depois de certo período de confusão). As linguagens formais têm significados exatamente iguais ao que expressam.\n\nComo todos nós crescemos falando linguagens naturais, às vezes é difícil se ajustar a linguagens formais. As linguagens formais são mais densas que as naturais, então exigem mais tempo para a leitura. Além disso, a estrutura é importante, então nem sempre é melhor ler de cima para baixo e da esquerda para a direita. Em vez disso, aprenda a analisar o programa primeiro, identificando os símbolos e interpretando a estrutura. E os detalhes fazem diferença. Pequenos erros em ortografia e pontuação, que podem não importar tanto nas linguagens naturais, podem fazer uma grande diferença em uma língua formal.\n\n1.2.1 Alto nível X Baixo nível\nNa ciência da computação, uma linguagem de programação de alto nível é uma linguagem de programação com forte abstração dos detalhes do computador. São linguagens mais próximas das linguagens humanas e mais distantes das linguagens de máquina. Em contraste com as linguagens de programação de baixo nível, ela pode usar elementos de linguagem natural, ser mais fácil de usar, ou pode automatizar (ou até ocultar totalmente) áreas significativas de sistemas de computação (por exemplo, gerenciamento de memória), tornando o processo de desenvolvimento de um programa mais simples e eficiente. Exemplos de linguagens de alto nível: Python, JavaScript.\nPor outro lado, uma linguagem de baixo nível é uma linguagem de programação que fornece pouca ou nenhuma abstração de conceitos de programação e está muito próxima de escrever instruções de máquina reais. A palavra “baixo” refere-se à pequena ou inexistente quantidade de abstração entre a linguagem e a linguagem de máquina; por causa disso, as linguagens de baixo nível são às vezes descritas como “próximas do hardware”. Programas escritos em linguagens de baixo nível tendem a ser relativamente não portáteis e dependentes do computador para o qual foram escritas. Exemplo de linguagem de baixo nível: Assembly\n\n\n1.2.2 Linguagem Compilada X Interpretada\nAs linguagens compiladas são convertidas diretamente em código de máquina que o processador pode executar. Como resultado, elas tendem a ser mais rápidos e eficientes de executar do que linguagens interpretadas. Eles também dão ao desenvolvedor mais controle sobre os aspectos de hardware, como gerenciamento de memória e uso da CPU. As linguagens compiladas precisam de uma etapa de “construção” – elas precisam ser compiladas manualmente primeiro. Você precisa “reconstruir” o programa toda vez que precisar fazer uma alteração. Exemplos de linguagens compiladas puras: C, C++, Go.\nUma linguagem interpretada é uma linguagem de programação que geralmente é interpretada, sem compilar um programa em instruções de máquina. É aquela em que as instruções não são executadas diretamente pela máquina de destino, mas lidas e executadas, linha por linha, por algum outro programa, um intérprete. As linguagens interpretadas já foram significativamente mais lentas do que as linguagens compiladas. Mas, com o desenvolvimento da compilação just-in-time, essa lacuna está diminuindo. Exemplos de linguagens interpretadas: Python e JavaScript\n\n\n1.2.3 Paradigmas\nPodemos dizer que paradigmas de programação são diferentes formas ou estilos em que um determinado programa ou linguagem de programação pode ser organizado. Cada paradigma consiste em certas estruturas, recursos e opiniões sobre como problemas comuns de programação devem ser abordados. Entre os principais paradigmas de programação podemos citar programação imperativa, programação declarativa e programação orientada a objetos. Na programação imperativa, por exemplo, o programador diz como, o quê e em qual ordem exatamente um programa ou rotina deve realizar. É neste paradigma que surgiram os famosos laços de repetição, estruturas condicionais, atribuição de valor à variáveis e controle de estado. Por outro lado, a programção declarativa não há preocupação na maneira ou método de execução de uma determinada rotina, o que importa é que a instrução seja realizada e não a forma como o será. Mais detalhes sobre paradigmas de programação podem ser obtidos aqui.\nPython é considerado uma linguagem de programação multi-paradigma, pois suporta orientação de objeto, programação imperativa e, em menor escala, programação funcional.\n\n\n1.2.4 Tipagem\nO Python utiliza tipagem dinâmica e forte, isso significa que o próprio interpretador do Python infere o tipo dos dados que uma variável recebe, sem a necessidade que o usuário da linguagem diga de que tipo determinada variável é. Hoje existem inúmeras linguagens no mercado que são fortemente tipadas, referenciando especificamente o Python para explicar a questão: tipagem forte significa que o interpretador do Python avalia as expressões por conta própria e não faz coerções automáticas (conversões de valores) entre tipos de dados não compatíveis. Ao fazer operações com tipos incompatíveis, o Python não converte automaticamente esses tipos pra você, ele vai dar erro. Isso é bom, pois assim você terá a certeza que o seu resultado é mais consistente.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentos de computação</span>"
    ]
  },
  {
    "objectID": "primeiros_passos.html",
    "href": "primeiros_passos.html",
    "title": "2  Primeiros passos no Python",
    "section": "",
    "text": "2.1 O Python\nIn summary, this book has no content whatsoever.\nPython foi criado no final dos anos oitenta(1989) por Guido van Rossum no Centro de Matemática e Tecnológia da Informação (CWI, Centrum Wiskunde e Informatica), na Holanda, como sucessor da linguagem de programação ABC, capaz de lidar com exceções e interagir com o sistema operacional Amoeba. O nome da língua vem do gosto de seu criador pelos humoristas britânicos Monty Python (fonte: https://blog.vulpi.com.br/python-como-surgiu/)\nPython é uma linguagem de programação de alto-nível, interpretada, multi-paradigma, e que usa tipagem dinâmica e forte.\nbla bla bla",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros passos no Python</span>"
    ]
  },
  {
    "objectID": "primeiros_passos.html#o-python",
    "href": "primeiros_passos.html#o-python",
    "title": "2  Primeiros passos no Python",
    "section": "",
    "text": "2.1.1 Porque escolher\nAssim como tudo na vida, o Python é uma linguagem de programação com muitas qualidades mas que também possui seus defeitos (em geral ligados à velocidade de execução dos programas). Em sendo uma linguagem de alto nível, é uma linguagem bastante indicada, por exemplo, para aplicações que demandam replicabilidade, dada a facilidade de escrever e interpretar o código. Por outro lado, aplicações que demandam uma interação mais eficiente entre o código e o gerenciamento de memória da máquina, por exemplo, podem se beneficiar de outras linguagens.\nNo entanto, o conjunto de qualidades do Python e as inúmeras bibliotecas que foram desenvolvidas nos últimos anos parecem ter mais do que compensado as falhas da linguagem. Hoje o Python é uma das principais linguagens de programação (senão a principal) quando o assunto é ciência dos dados e aprendizado de máquina (data science e machine learning, respectivamente). É também uma das principais linguagens de programação por trás de vários dos sistemas de grandes empresas, como Uber, GoldmanSachs, Netflix e Google (fonte: link).\nPor todos esses fatores, Python é uma das linguagens com a comunidade mais ativa em fóruns online voltados à programação e é a linguagem que mais cresce no mundo. As figuras abaixo ilustram bem esse crescimento da linguagem nos últimos anos:\n \n\n\n2.1.2 Como instalar\nExiste mais de uma forma de instalar o Python no seu sistema e ainda mais formas de interagir com a linguagem. Você pode baixar o Python puro (https://www.python.org/downloads/) e instalá-lo diretamente em sua máquina, porém, essa distribuição vem com poucos pacotes já instalados e instalá-los um a um requer paciência. Além disso, a instalação do Python puro pode demandar algumas alterações em configurações do sistema via prompt de comando do Windows, por exemplo, para que seja possível dialogar com a linguagem.\n  \nUma forma mais simples de instalar o Python em seu computador é através da distribuição Anaconda (https://www.anaconda.com/). Além de ser gratuita e conter vários dos pacotes que iremos utilizar, ela nos fornece diversas ferramentas que facilitam nossa interação com a linguagem. É hoje uma das distribuições do Python mais populares no mundo! Recomendo fortemente utilizar esse caminho.\nO passo a passo a seguir foi feito para o sistema Windows 10. Embora o caminho seja parecido, podem haver algumas divergências em relação ao passo a passo para sistemas Linux e MacOS.\n\n\nBaixar e instalar o Anaconda é fácil. Basta acessar a aba de downloads no site do Anaconda (https://www.anaconda.com/download), fornecer um email para cadastro e baixar o arquivo executável necessário para a instalação a depender do seu sistema operacional.\n\n  \n\nDepois de baixado, basta clicar duas vezes sobre o arquivo e ir acompanhando o instalador, mantendo sempre as opções padrão e escolhendo a opção de instalar para todos os usuários do computador, o que requer acesso de administrador.\n\n  \n\nPronto, o Anaconda está instalado e os principais pacotes e programas que utilizaremos também! \n\n\n\n2.1.3 Anaconda e suas particularidades\nComo dito acima, anaconda é uma distribuição do Python para computação científica (e.g, ciência de dados e aprendizado de máquina), que visa simplificar o gerenciamento e a implantação de pacotes. As versões de pacotes no Anaconda são gerenciadas pelo sistema de gerenciamento de pacotes conda. Através do conda é possível criar ambientes e instalar pacotes distintos de forma a evitar incompatibilidades entre versões de pacotes já instalados.\nAlém disso, o anaconda traz consigo o Anaconda Navigator, um ambiente user-friendly para a gestão de pacotes e aplicativos necessários para a utilização do Python sem que seja preciso ter qualquer conhecimento acerca da utilização correta de terminais (e.g, prompt de comando do Windows). Ao abrir o Anaconda Navigator no Windows, você deve ver algo assim\n  \nÉ possível instalar pacotes e fazer muito mais coisa diretamente pelo Anaconda Navigator. Para os que tiverem interesse em saber um pouco mais, esse vídeo é um bom começo.\n\n\n2.1.4 Instalando pacotes\nPara instalar novos pacotes para o Python precisamos fazê-lo via prompt de comando. O Anaconda nos fornece um prompt de comando próprio, o Anaconda Prompt que facilita a instalação desses pacotes através dos comandos conda ou pip. Vamos instalar como exemplo o pacote tqdm, que nos permite criar barras de progresso em atividades repetidas.\n\nAbra o Anaconda prompt.\nVeja se o pacote já não está instalado: digite conda list.\nVocê pode utilizar 2 comandos distintos para instalar o pacote: conda install tqdm ou pip install tqdm.\n\nNote também que alguns dos principais pacotes sobre os quais falarei ao longo do curso, NumPy, SciPy, Matplotlib e Pandas, já vem instalados com o Anaconda, o que não é verdade no Python puro. Mais do que mostrar o que temos instalado na nossa máquina local, o comando conda list nos mostra as versões de cada uma das bibliotecas disponíveis e qual o ambiente utilizado em sua instalação.\n\nDiferença entre conda e pip: falar mais sobre a diferença entre esses dois comandos populares para instalação de pacotes vai um pouco além do escopo desse curso. De forma bastante resumida, podemos dizer que o pip é um gerenciador de pacotes que nos permite instalar qualquer biblioteca escrita em Python e disponível no Python Package Index (PyPI), o principal repositório de pacotes para a linguagem. O conda, no entanto, é mais do que um simples gerenciador de pacotes já que é possível fazer diferentes instalações em diferentes ambientes de modo a reduzir problemas de incompatibilidade entre versões. Além disso, através do conda podemos instalar pacotes escritos em outras linguagens também, como R e C++. Por outro lado, é possível que você demore mais e tenha problemas para instalar alguns pacotes utilizando o conda. Aos que quiserem saber um pouco mais sobre a diferença entre esses dois métodos para instalação, esses links (1 e 2) podem ser um bom começo.\n\n\n2.1.5 IDEs\nIDE é um acrônimo para Integrated Development Environment, em português, Ambiente de Desenvolvimento Integrado. Ele é um programa que reúne ferramentas necessárias para a construção de outros softwares. A utilização de um IDE ajuda muito os programadores e empresas, pois torna mais rápido o desenvolvimento de aplicações, aumentando a produtividade e reduzindo custos. Existem IDE’s específicas para plataformas, e outras que são mais flexíveis. As mais famosas são o Sublime Text e o Visual Studio Code.\nQuais são os componentes típicos de uma IDE?\n\nEditor de código-fonte: Permite edição do código nas linguagens de programação suportadas pelo IDE.\nPreenchimento inteligente: Esse é um recurso trazido pelos IDEs que agiliza o desenvolvimento, pois escreve automaticamente trechos do código como, por exemplo, comandos de função.\nCompilador: O compilador que você escreveu em uma determinada linguagem de programação para a linguagem de máquina, de modo que os computadores o entendam.\nDebugger: É outra ferramenta que contribui para no código-fonte, melhorando o desempenho do programa.\nGeração de código: Com esse recurso, é possível predefinir trechos de códigos para serem usados de modelo em outros projetos, agilizando o desenvolvimento de trabalhos futuros.\n\nComo podemos ver, os IDEs reúnem diversas ferramentas que tornam mais simples a vida dos programadores. Dentre todos os benefícios que a utilização desses programas pode trazer para seus projetos, podemos citar alguns:\n\nReduz o tempo gasto em cada aplicação;\nPermite o desenvolvimento de um código mais limpo, organizado e legível;\nAumenta a produtividade dos desenvolvedores e das empresas;\nReduz a quantidade de bugs e falhas no código-fonte;\nReúne diversas ferramentas em um só lugar.\n\n\n2.1.5.1 Spyder\nO Spyder é uma ferramenta leve, simples e ao mesmo tempo poderosa. É um IDE Python de código aberto que conta com elementos avançados de edição, depuração e testes interativos. Ele é bastante utilizado para o aprendizado de Data Science, apesar de não fornecer ferramentas tão avançadas nesse sentido como outras disponíveis. Mas ele é prático e seu depurador destaca bem funções, variáveis e erros. Conta também com um recurso de exploração de variáveis, que exibe os conteúdos armazenados dentro de cada uma. Isso poupa a escrita de comandos de impressão de variáveis na tela.\nDisponível com a instalação do Anaconda, uma das maiores e mais utilizadas plataformas de distribuição do Python.\n\n\n2.1.5.2 Jupyter\nÉ um IDE Python gratuito, utilizado principalmente na análise e ciência de dados. Ele é fácil e intuitivo, proporcionando um bom ambiente para iniciantes em Python. Também conta com muitos materiais de referência, tornando-se um dos IDEs mais utilizados pela comunidade. Ele trabalha muito bem com grandes conjuntos de dados. Além disso, é ótimo para a estética do código e atua como uma. É possível visualizar e editar facilmente seu código para deixá-lo mais atraente e apresentável.\nAlém de tudo isso, a estrutura do Jupyter serve muito ao propósito de tornar o código mais facilmente replicável, já que é possível intercalar células de comentários e explicações em linguagem Markdown com células de código propriamente dito, seguidas do resultado (ou erros) das instruções. Ele possui ainda integrações com HTML, por exemplo, que fazem a diferença principalmente na hora de apresentar projetos ou utilizá-los para o aprendizado. O material aula a aula do nosso curso, por exemplo, foi inteiramente desenvolvido e criado no Jupyter!\n\n\n2.1.5.3 Google Colaboratory\nO Google Colaboratory, carinhosamente chamado de Colab, é um serviço de nuvem gratuito hospedado pelo próprio Google para incentivar a pesquisa de Aprendizado de Máquina e Inteligência Artificial.\nÉ uma ferramenta que permite que você misture código fonte (geralmente em python) e texto rico (geralmente em markdown) com imagens e o resultado desse código, assim como o próprio Jupyter e sua estrutura de notebooks (“cadernos” em inglês). Uma diferença importante é que no caso do Colab os recursos computacionais utilizados para a execução do código são os da Google e não do seu computador. Apesar da versão gratuita disponibilizar apenas algo como 12GB de RAM, é possível ampliar essa capacidade de processamento da máquina virtual por uma conta paga que começa em $5 mensais.\n\n\n\n2.1.6 Spyder X Jupyter\nAlguns dos pacotes mais utilizados no Python hoje em dia, como Pandas e Matplotlib, já vem instalados com o Anaconda, o que não é verdade na distribuição pura do Python. Além disso, alguns dos programas mais utilizados para interagir com a linguagem, como o Spyder e o Jupyter Notebook também. Tanto o Spyder quanto o Jupyter são ótimas IDEs para trabalhar com o Python, embora cada um tenha suas particularidades.\nExistem vários comparativos entre essas duas formas (e tantas outras) de trabalhar com o Python (1, 2 e 3), mas no nosso caso talvez seja mais produtivo se formos direto para ambos os programas!\nAcabamos de ver que uma das diferenças mais relevantes para nós, iniciantes na linguagem, ao usar o Spyder ou o Jupyter é a dificuldade, no segundo caso, de fazer uma gestão mais direta das variáveis criadas e da memória utilizada por cada uma delas. É possível, no entanto, superar essa dificuldade através de uma biblioteca que pode ser bastante útil para nós, o nbextensions (documentação aqui e aqui).\nVamos primeiro instalar essa biblioteca e mais uma outra biblioteca auxiliar que nos permitirá ter um controle maior sobre as extensões. Rode os comandos abaixo no Anaconda Prompt\n\npip install jupyter_contrib_nbextensions\npip install jupyter_nbextensions_configurator\n\nNote que uma nova aba Nbextensions foi criada na “Home Page” do Jupyter Notebook. Ali é possível ativar e desativar as extensões que possam ser interessante ao nosso propósito. Agora já podemos brincar um pouco com tudo que ela pode nos fornecer!",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros passos no Python</span>"
    ]
  },
  {
    "objectID": "primeiros_passos.html#construindo-o-primeiro-programa",
    "href": "primeiros_passos.html#construindo-o-primeiro-programa",
    "title": "2  Primeiros passos no Python",
    "section": "2.2 Construindo o primeiro programa",
    "text": "2.2 Construindo o primeiro programa\nTradicionalmente, o primeiro programa que se escreve em uma nova linguagem chama-se “Hello, World!”, porque tudo o que faz é exibir as palavras “Hello, World!” na tela. No Python, ele se parece com isto:\nprint('Hello, World!')\nEste é um exemplo de uma instrução print (instrução de impressão), embora na realidade ela não imprima nada em papel. Ela exibe um resultado na tela. As aspas apenas marcam o começo e o fim do texto a ser exibido; elas não aparecem no resultado. Os parênteses indicam que o print é uma função. No Python 2, a instrução print é ligeiramente diferente; ela não é uma função, portanto não usa parênteses.\n\n2.2.1 Operadores aritméticos\nDepois do “Hello, World”, o próximo passo é a aritmética. O Python tem operadores, que são símbolos especiais representando operações de computação, como adição e multiplicação. Os operadores +, - e * executam a adição, a subtração e a multiplicação, Finalmente, o operador ** executa a exponenciação; isto é, eleva um número a uma potência, como nos seguintes exemplos:\n40 + 2\n43 - 1\n6 * 7\n84 / 2\n6 ** 2 + 6\nEm algumas outras linguagens, o ^ é usado para a exponenciação, mas no Python é um operador bitwise, chamado XOR. Se não tiver familiaridade com operadores bitwise, o resultado o surpreenderá. Não abordaremos operadores bitwise neste curso, mas você pode ler sobre eles em http://wiki.python.org/moin/BitwiseOperators.\n6 ^ 2\nUm valor é uma das coisas básicas com as quais um programa trabalha, como uma letra ou um número. Alguns valores que vimos até agora foram 2, 42.0 e ‘Hello, World!’.\nEsses valores pertencem a tipos diferentes: 2 é um número inteiro, 42.0 é um número de ponto flutuante e ‘Hello, World!’ é uma string, assim chamada porque as letras que contém estão em uma sequência em cadeia.\nSe não tiver certeza sobre qual é o tipo de certo valor, o interpretador pode dizer isso a você:\ntype(2)\ntype(42.0)\ntype('Hello World')\nNesses resultados, a palavra “class” (classe) é usada no sentido de categoria; um tipo é uma categoria de valores. Como se poderia esperar, números inteiros pertencem ao tipo int, strings pertencem ao tipo str e os números de ponto flutuante pertencem ao tipo float.\nE valores como ‘2’ e ‘42.0’? Parecem números, mas estão entre aspas como se fossem strings:\ntype('2')\nUm dos recursos mais eficientes de uma linguagem de programação é a capacidade de manipular variáveis. Uma variável é um nome que se refere a um valor.\n\n\n2.2.2 Instruções de atribuição\nUma instrução de atribuição cria uma nova variável e dá um valor a ela:\nmessage = 'And now for something completely different'\nn = 17\npi = 3.141592653589793\nEsse exemplo faz três atribuições. A primeira atribui uma string a uma nova variável chamada message; a segunda dá o número inteiro 17 a n; a terceira atribui o valor (aproximado) de \\(\\pi\\) a pi. Uma forma comum de representar variáveis por escrito é colocar o nome com uma flecha apontando para o seu valor. Este tipo de número é chamado de diagrama de estado porque mostra o estado no qual cada uma das variáveis está (pense nele como o estado de espírito da variável).\n\n\n2.2.3 Nomes de variáveis\nOs programadores geralmente escolhem nomes significativos para as suas variáveis – eles documentam o uso da variável. Nomes de variáveis podem ser tão longos quanto você queira. Podem conter tanto letras como números, mas não podem começar com um número. É legal usar letras maiúsculas, mas a convenção é usar apenas letras minúsculas para nomes de variáveis. O caractere de sublinhar (_) pode aparecer em um nome. Muitas vezes é usado em nomes com várias palavras, como your_name ou airspeed_of_unladen_swallow.\nSe você der um nome ilegal a uma variável, recebe um erro de sintaxe:\n76trombones = 'big parade'\nmore@ = 1000000\nclass = 'Advanced Theoretical Zymurgy'\n76trombones é ilegal porque começa com um número. more@ é ilegal porque contém um caractere ilegal, o @. Mas o que há de errado com class?\nA questão é que class é uma das palavras-chave do Python. O interpretador usa palavras-chave para reconhecer a estrutura do programa e elas não podem ser usadas como nomes de variável. O Python 3 tem estas palavras-chave:\nand         del         from        None        True\nas          elif        global      nonlocal    try\nassert      else        if          not         while\nbreak       except      import      or          with\nclass       False       in          pass        yield\ncontinue    finally     is          raise\ndef         for         lambda      return\nVocê não precisa memorizar essa lista. Na maior parte dos ambientes de desenvolvimento, as palavras-chave são exibidas em uma cor diferente; se você tentar usar uma como nome de variável, vai perceber.\n\n\n2.2.4 Expressões e instruções\nUma expressão é uma combinação de valores, variáveis e operadores. Um valor por si mesmo é considerado uma expressão, assim como uma variável, portanto as expressões seguintes são todas legais:\nn\nn + 25\nQuando você digita uma expressão no prompt, o interpretador a avalia, ou seja, ele encontra o valor da expressão. Neste exemplo, o n tem o valor 17 e n + 25 tem o valor 42.\nUma instrução é uma unidade de código que tem um efeito, como criar uma variável ou exibir um valor.\n&gt;&gt;&gt; n = 17\n&gt;&gt;&gt; print(n)\nA primeira linha é uma instrução de atribuição que dá um valor a n. A segunda linha é uma instrução de exibição que exibe o valor de n. Quando você digita uma instrução, o interpretador a executa, o que significa que ele faz o que a instrução diz. Em geral, instruções não têm valores.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros passos no Python</span>"
    ]
  },
  {
    "objectID": "primeiros_passos.html#exercícios",
    "href": "primeiros_passos.html#exercícios",
    "title": "2  Primeiros passos no Python",
    "section": "2.3 Exercícios",
    "text": "2.3 Exercícios\n\nInicialize o interpretador do Python e use-o como uma calculadora. Responda as seguintes perguntas:\n\nQuantos segundos há em 42 minutos e 42 segundos?\nQuantas milhas há em 10 quilômetros? Dica: uma milha equivale a 1,61 quilômetro.\nSe você correr 10 quilômetros em 42 minutos e 42 segundos, qual é o seu passo médio (tempo por milha em minutos e segundos)? Qual é a sua velocidade média em milhas por hora?\n\nCrie uma conta no StackOverflow e monte seu perfil.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros passos no Python</span>"
    ]
  },
  {
    "objectID": "inteligencia_artificial.html",
    "href": "inteligencia_artificial.html",
    "title": "3  Programação e IA",
    "section": "",
    "text": "3.1 StackOverflow\nIn summary, this book has no content whatsoever.\nStack Overflow é um site de perguntas e respostas, um fórum, para programadores profissionais e entusiastas. É o site principal da Stack Exchange Network. Foi criado em 2008 por Jeff Atwood e Joel Spolsky.Ele apresenta perguntas e respostas sobre uma ampla gama de tópicos em programação de computadores. Ele foi criado para ser uma alternativa mais aberta aos sites anteriores de perguntas e respostas, como o Experts-Exchange. O Stack Overflow foi vendido para a Prosus, um conglomerado de internet para consumidores com sede na Holanda, em 2 de junho de 2021 por US$ 1,8 bilhão.\nO site serve como uma plataforma para os usuários fazerem e responderem perguntas e, por meio de associação e participação ativa, votarem em perguntas e respostas semelhantes ao Reddit e editarem perguntas e respostas de maneira semelhante a um wiki. Os usuários do Stack Overflow podem ganhar pontos de reputação e “emblemas”; por exemplo, uma pessoa recebe 10 pontos de reputação por receber um voto “para cima” em uma pergunta ou resposta a uma pergunta, e pode receber medalhas por suas valiosas contribuições, o que representa uma gamificação do tradicional Q&A local na internet. Os usuários desbloqueiam novos privilégios com um aumento na reputação, como a capacidade de votar, comentar e até editar as postagens de outras pessoas.\nEm março de 2021, o Stack Overflow tinha mais de 14 milhões de usuários registrados e recebeu mais de 21 milhões de perguntas e 31 milhões de respostas. Esse fórum, juntamente com outros sites de perguntas e respostas de programação semelhantes, substituíram globalmente principalmente os livros de programação para referência de programação do dia-a-dia nos anos 2000, e hoje são uma parte importante da programação de computadores. Vocês lembram do nosso gráfico de participação de algumas das principais linguagens no total de perguntas do StackOverflow? Qual linguagem está em 1º lugar desde o fim de 2018?\nMas pera lá, o que significa esse monte de adjetivo? (fontes: computersciencewiki.org, geeksforgeeks.org, freecodecamp.org)",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Programação e IA</span>"
    ]
  },
  {
    "objectID": "objetos.html",
    "href": "objetos.html",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "",
    "text": "4.1 Strings\nIn summary, this book has no content whatsoever.\nStrings não são como números inteiros ou de ponto flutuate. No Python, uma string nada mais é do que uma sequência ordenada de caracteres unicode. Eles são delimitados sempre por aspas (simplas ou duplas). Relembrando nosso primeiro “programa” da aula passada podemos atribuir a uma variável a string Hello, World usando aspas.\nstr1 = 'Hello, World'\n\nprint(str1)\nprint(type(str1))\n\nHello, World\n&lt;class 'str'&gt;\nUsando aspas duplas o resultado seria o mesmo\nstr2 = \"Hello, World\"\n\nprint(str2)\nprint(type(str2))\n\nHello, World\n&lt;class 'str'&gt;\nNote que podemos também usar uma sequência de três aspas duplas e escrever strings que percorrem várias linhas.\nstr3 = \"\"\"Das Utopias\n\nSe as coisas são inatingíveis...ora!\nNão é motivo para não querê-las...\nQue tristes os caminhos, se não fora\nA presença distante das estrelas!\n           \nMario Quintana \n\"\"\"\n\nprint(str3)\nprint(type(str3))\n\nDas Utopias\n\nSe as coisas são inatingíveis...ora!\nNão é motivo para não querê-las...\nQue tristes os caminhos, se não fora\nA presença distante das estrelas!\n\nMario Quintana \n\n&lt;class 'str'&gt;",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#strings",
    "href": "objetos.html#strings",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "",
    "text": "4.1.1 Operações básicas\nPor ser uma sequência de caracteres e não um número, operações aritméticas (em geral) não são permitidas, mas outras operações, como slicing, o são. É possível acessar um caracter específico da sequência utilizando a posição desse caractere, utilizando o que chamamos de índice. No caso do string ‘Hello, World’, para acessar a segunda letra podemos utilizar colchetes após o string e dentro dele o índice referente à posição do ‘e’ no string:\n\nprint(str1)\n\nHello, World\n\n\n\nstr1[2]\n\n'l'\n\n\nUé, mas porque que obtivemos como resposta o caractere ‘l’, que é o 3º na sequência, e não o ‘e’, que é o 2º elemento? Aqui vai uma particularidade da sintaxe do Python: em se tratando de índices, o Python sempre começa a contagem em 0!. Dessa forma, para acessar o primeiro caractere de ‘Hello, World’ devemos pedir str1[0], para acessar o segundo é preciso pedir str1[1] e assim por diante.\n\nstr1[1]\n\n'e'\n\n\nPodemos acessar contando de trás para frente e usando um índice negativo\n\nstr1[-11]\n\n'e'\n\n\nÉ possível que o índice seja uma expressão, mas deve sempre ser um valor inteiro.\n\nn=0\nstr1[n+1]\n\n'e'\n\n\n\nstr1[1.5]\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 str1[1.5]\n\nTypeError: string indices must be integers, not 'float'\n\n\n\nPara acessar uma fatia (slice) do string podemos utilizar um intervalo de índices (inclusive o índice inicial e exclusive o índice final). Por exemplo,\n\nstr1[0:5]\n\n'Hello'\n\n\nAlém de ser possível calcular o número de caracteres em uma sequência string utilizando a função integrada len(), podemos “concatenar” ou “somar” strings utilizando apenas o sinal de +\n\nlen(str1)\n\n12\n\n\n\nstr1 + ' --- ' + str2\n\n'Hello, World --- Hello, World'\n\n\nNote, porém, que strings são imutáveis, de modo que caso queira substituir um dos caracteres dentro de um string é preciso utilizar uma função específica para isso ou criar um novo string derivado do 1º. Apenas tentar substituir um dos caracteres de um string já definido não é permitido.\n\n# Tentemos substituir o 'e' do str1 por 'a'\nstr1[1] = 'a'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 2\n      1 # Tentemos substituir o 'e' do str1 por 'a'\n----&gt; 2 str1[1] = 'a'\n\nTypeError: 'str' object does not support item assignment\n\n\n\n\n\n4.1.2 Métodos de strings\nAs strings oferecem métodos que executam várias operações úteis. Um método é em essência uma sequência de instruções encapsuladas dentro de um único comando que recebe argumentos e devolve um valor. Embora a sintaxe seja diferente, a ideia é a mesma quando falamos de funções, objeto do nosso estudo daqui algumas aulas.\nNo caso dos métodos, temos que passar o nome da string que foi definida anteriormente seguida de ‘.’ e depois do comando relacionado ao método específico. Dentre os principais métodos aplicáveis a strings e suas funcionalidades podemos citar: \n\nstr_example.upper(): devolve a string ‘str_example’ toda em letras maiúsculas. \nstr_example.lower(): devolve a string ‘str_example’ toda em letras minúsculas. \nstr_example.strip(): devolve a string ‘str_example’ retirando possíveis espaços em branco no início e no fim da string. \nstr_example.startswith(‘xyz’): testa se a string ‘str_example’ começa com a string ‘xyz’. \nstr_example.endswith(‘xyz’): testa se a string ‘str_example’ termina com a string ‘xyz’. \nstr_example.find(‘xyz’): procura a string ‘xyz’ dentro de ‘str_example’ e retorna o primeiro índice onde ‘xyz’ começa ou retorna -1 se nada for encontrado. \nstr_example.replace(‘old’,‘new’): retorna uma string nova onde todas as ocorrências de ‘old’ encontradas em ‘str_example’ serão substituídas por ‘new’. \n\nAlém desses principais, existem outros vários métodos para strings. Esse link é um bom ponto de partida para quem quiser conhecer outros exemplos.\n\nstr1 = ' Hello, World '\n\nprint(str1.upper())\nprint(str1.lower())\n\n HELLO, WORLD \n hello, world \n\n\n\nprint(str1.strip())\n\nHello, World\n\n\n\nprint(str1.startswith(' '))\nprint(str1.endswith('d'))\n\nTrue\nFalse\n\n\n\nprint(str1.find(','))\n\n6\n\n\n\nprint(str1.replace('Hello','World'))\n\n World, World \n\n\n\n\n4.1.3 Formatação e a instrução print\nUm método sobre o qual não falamos, mas que é bastante interessante quando queremos, por exemplo, printar bonitinho o resultado de determinada operação é s.format(). Com esse método podemos converter uma variável numérica para uma formato específico e printá-la dentro de um string maior. Imagine, por exemplo, que estejamos interessados em printar o valor de \\(\\pi\\) arredondado para 2 casas decimais apenas dentro de um string que diz isso. Podemos implementar isso da seguinte forma\n\npi = 3.1415926535\nprint('O valor de pi arredondado para 2 casas decimais é {:.2f}. Interessante, não?'.format(pi))\n\nO valor de pi arredondado para 2 casas decimais é 3.14. Interessante, não?\n\n\nOs colchetes dentro do string mostram onde que o número deve aparecer. Mais do que isso, definimos dentro do colchete o formato do número. Após os ‘:’, o ‘.2’ significa que queremos 2 casas decimais enquanto ‘f’ significa que queremos um formato de ponto fixo. Não vou entrar nos detalhes de todas as formatações possíveis, mas podemos ver um pouco mais disso aqui.\nPodemos também usar mais de um número dentro do mesmo método format. Por exemplo,\n\nprint('O valor de pi arredondado para 2 casas decimais é {:.2f}. Com 4 casas decimais, no entanto, o número é um pouco maior e igual a {:.4f}. Interessante, não?'.format(pi,pi))\n\nO valor de pi arredondado para 2 casas decimais é 3.14. Com 4 casas decimais, no entanto, o número é um pouco maior e igual a 3.1416. Interessante, não?\n\n\n\n\n4.1.4 Introdução a expressões regulares\nPor vezes queremos encontrar um padrão específico de texto (e.g., placas de carro, e-mails ou números de telefone) dentro de um texto maior, para realizar algum tipo de coleta, limpeza ou mesmo substituição que um simples str.replace() não dá conta. Para realizar tal ação podemos utilizar as famosas Expressões Regulares, também conhecidas como Regular Expressions no inglês, ou simplesmente Regex.\nAs expressões regulares são em essência uma potente linguagem para especificar padrões de texto. De forma mais detalhada, é uma composição dos chamados metacaracteres, caracteres com funções especiais, que, agrupados entre si e em conjunto com caracteres literais, formam uma sequência, uma expressão. Essa expressão é interpretada como uma regra que indicará sucesso se uma entrada de dados qualquer casar com essa regra, ou seja, obedecer exatamente a todas as suas condições.\nImagine que você tenha o string abaixo, que mostra o texto de um trecho de uma notícia da CNN sobre o resultado da Pesquisa Datafolha para presidente divulgada em 18/08/2022 (link para a matéria completa aqui).\n\npesquisa = \"\"\"\nPesquisa Datafolha divulgada nesta quinta-feira (18) mostra o ex-presidente Luiz Inácio Lula da Silva (PT) à frente, \ncom 47% das intenções de voto na corrida pelo Palácio do Planalto. O presidente Jair Bolsonaro (PL) tem 32%. \nO primeiro turno das eleições acontece em 2 de outubro.\n\nNa sequência, aparecem Ciro Gomes (PDT), com 7%; Simone Tebet (MDB), com 2%, e Vera Lúcia (PSTU), com 1%.\n\"\"\"\n\nprint(pesquisa)\n\n\nPesquisa Datafolha divulgada nesta quinta-feira (18) mostra o ex-presidente Luiz Inácio Lula da Silva (PT) à frente, \ncom 47% das intenções de voto na corrida pelo Palácio do Planalto. O presidente Jair Bolsonaro (PL) tem 32%. \nO primeiro turno das eleições acontece em 2 de outubro.\n\nNa sequência, aparecem Ciro Gomes (PDT), com 7%; Simone Tebet (MDB), com 2%, e Vera Lúcia (PSTU), com 1%.\n\n\n\nE se quiséssemos, por exemplo, substituir todas as porcentagens de intenção de voto por ‘ZZZ’? Note que as porcentagens são diferentes e não há uma repetição dos números que nos permita usar o str.replace() de uma vez só. No entanto, todas as porcentagens são representadas por 1 ou 2 números inteiros seguidos do símbolo \\(\\%\\). Nesse caso, o mais indicado é utilizar as expressões regulares.\nOs módulos e funções nativas do Python não nos trazem muito material para trabalhar com expressões regulares. Para operar com elas utilizaremos uma biblioteca de comandos chamada re. Para trazer para dentro do Python as funcionalidades dessa biblioteca precisamos utilizar a função import seguida do nome da biblioteca.\n\nimport re\n\nFalaremos mais sobre importação de bibliotecas de comandos e funções mais a frente, mas por hora tenha na cabeça que para utilizar um conjunto de instruções disponível em alguma biblioteca importada é preciso utilizar o nome da biblioteca seguido de ponto e do nome da função dessa biblioteca que você quer utilizar. No caso, para realizar a substituição das porcentagens no string pesquisa utilizaremos a função sub() de dentro da biblioteca re. Mas o que devemos colocar como input dessa função?\nO mundo das expressões regulares é um mundo gigante e à parte, com conteúdo suficiente para preencher um outro curso. De forma geral, a combinação entre metacaracteres e caracteres literais é o que dá o padrão do texto pelo qual procuramos. Alguns dos metacaracteres-padrão são . ? * + ^ | [ ] { } ( ) \\, cada um realizando uma função específica. Para o nosso caso utilizaremos basicamente a expressão regular dada por\n[0-9]{1,2}%\nMas o que essa coisa bizarra diz de fato? A função buscará todo e qualquer elemento dentro dos colchetes (no caso os dígitos numéricos) que apareça uma ou duas vezes (código dentro dos colchetes) e que seja seguido pelo símbolo de porcentagem. Note que esse é o padrão de qualquer uma das porcentagens no nosso string pesquisa. Vamos ver o que acontece se usarmos isso dentro de re.sub().\n\npesquisa2 = re.sub('[0-9]{1,2}%','ZZZ',pesquisa)\n\n\nprint(pesquisa)\n\n\nPesquisa Datafolha divulgada nesta quinta-feira (18) mostra o ex-presidente Luiz Inácio Lula da Silva (PT) à frente, \ncom 47% das intenções de voto na corrida pelo Palácio do Planalto. O presidente Jair Bolsonaro (PL) tem 32%. \nO primeiro turno das eleições acontece em 2 de outubro.\n\nNa sequência, aparecem Ciro Gomes (PDT), com 7%; Simone Tebet (MDB), com 2%, e Vera Lúcia (PSTU), com 1%.\n\n\n\n\nprint(pesquisa2)\n\n\nPesquisa Datafolha divulgada nesta quinta-feira (18) mostra o ex-presidente Luiz Inácio Lula da Silva (PT) à frente, \ncom ZZZ das intenções de voto na corrida pelo Palácio do Planalto. O presidente Jair Bolsonaro (PL) tem ZZZ. \nO primeiro turno das eleições acontece em 2 de outubro.\n\nNa sequência, aparecem Ciro Gomes (PDT), com ZZZ; Simone Tebet (MDB), com ZZZ, e Vera Lúcia (PSTU), com ZZZ.\n\n\n\nConseguimos exatamente o que a gente queria. Boa, time!\nPare um pouco e pense sobre a aplicabilidade dessa ferramenta dentro de um mundo repleto de dados não-estruturados, como tweets e notícias. O potencial de uso é gigante! Mas como dissemos, o mundo de regex é muito grande e existem cursos e livros que se dedicam integralmente a estudar essa linguagem de padrões textuais. Uma boa referência introdutória é o livro Expressões Regulares: Uma Abordagem Divertida.\nSe eu pudesse dar um conselho para o meu eu de 15 anos atrás seria: beba água e estude expressões regulares.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#listas",
    "href": "objetos.html#listas",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "4.2 Listas",
    "text": "4.2 Listas\nComo uma string, uma lista é uma sequência de valores. Em uma string, os valores são caracteres; em uma lista, eles podem ser de qualquer tipo. Podemos ter uma lista de strings, uma lista de valores numéricos ou mesmo uma lista de listas, combinando strings, números e mesmo outros tipos de objetos que ainda veremos, como tuplas, dicionários e dataframes.\nUma lista é delimitada por colchetes e os elementos, ou itens, pertencentes a ela são separados por vírgula. Para definir uma lista com 5 números inteiros, ordenados de forma sequencial e começando em 1 devemos escrever a seguinte linha de código:\n\nlista1 = [1,2,3,4,5]\n\nprint(lista1)\nprint(type(lista1))\n\n[1, 2, 3, 4, 5]\n&lt;class 'list'&gt;\n\n\nPodemos definir uma lista de strings, uma lista mista de strings e números, e uma lista composto por outras listas (lista aninhada):\n\nlista2 = ['Danilo Souza','Claudio Lucinda']\nlista3 = ['Turma 2024201',46.0,'Turmas 2024202',49,'Turmas 2024221',81]\nlista4 = [lista1, lista2]\n\nprint(lista2)\nprint(lista3)\nprint(lista4)\n\n['Danilo Souza', 'Claudio Lucinda']\n['Turma 2024201', 46.0, 'Turmas 2024202', 49, 'Turmas 2024221', 81]\n[[1, 2, 3, 4, 5], ['Danilo Souza', 'Claudio Lucinda']]\n\n\nDe forma análoga à listas com elementos não vazios, é possível definir uma lista vazia utilizando apenas os colchetes:\n\nlista_vazia = []\n\nprint(lista_vazia)\n\n[]\n\n\n\n4.2.1 Operações básicas\nA sintaxe para acessar os elementos de uma lista é a mesma que para acessar os caracteres de uma string: o operador de colchete. A expressão dentro dos colchetes especifica o índice ou o intervalo de índices. Lembrando que o índice no Python começa em ZERO e não em UM\n\nprint(lista2[0])\nprint(lista2[1])\nprint(lista3[-1])\nprint(lista3[0:2])\n\nDanilo Souza\nClaudio Lucinda\n81\n['Turma 2024201', 46.0]\n\n\nDiferente das strings, listas são mutáveis. Quando o operador de colchete aparece do lado esquerdo de uma atribuição, ele identifica o elemento da lista que será atribuído:\n\nnumbers = [42, 123]\nnumbers[1] = 5\nnumbers\n\n[42, 5]\n\n\nO segundo elemento de numbers (índice 1), que era 123, agora é 5.\nÍndices de listas funcionam da mesma forma que os índices de strings:\n\nQualquer expressão de números inteiros pode ser usada como índice.\nSe tentar ler ou escrever um elemento que não existe, você recebe um IndexError.\nSe um índice tiver um valor negativo, ele conta de trás para a frente, a partir do final da lista.\n\nO operador in, que serve ao propósito de testar a existência de determinado elemento dentro de um objeto específico, também funciona com listas:\n\ncheeses = ['Cheddar', 'Gorgonzola', 'Gouda']\n'Edam' in cheeses\n\nFalse\n\n\n\n'Brie' in cheeses\n\nFalse\n\n\nAssim como com strings, é possível calcular o número de elementos em uma lista utilizando a função integrada len() e “concatenar” ou “somar” listas utilizando apenas o sinal de +\n\nprint(len(cheeses))\n\n3\n\n\n\nlista_soma = lista2 + cheeses\nprint(lista_soma)\n\n['Danilo Souza', 'Claudio Lucinda', 'Cheddar', 'Gorgonzola', 'Gouda']\n\n\n\n\n4.2.2 Métodos de listas\nAs listas também possuem métodos bastante úteis, que nos facilitam a vida em várias dimensões. Dentre os principais métodos aplicáveis a listas e suas funcionalidades podemos citar: \n\nlista_example.append(): adiciona um novo elemento ao fim da lista “lista_example”. \nlista_example.extend(lista2): toma a lista “lista_example” como argumento e adiciona todos os elementos de lista2 como novos elementos da lista inicial. \nlista_example.sort(): classifica os elementos de “lista_example” em ordem ascendente. \nlista_example.remove(x): exclui o elemento igual a “x” de “lista_example”. É um método bastante útil quando queremos excluir um elemento específico, mas não sabemos sua posição dentro da lista. \n\nA maior parte dos métodos de listas são nulos; eles alteram a lista e retornam None. Se você escrever t = t.sort() por acidente, ficará desapontado com o resultado.\n\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\n\n['a', 'b', 'c', 'd']\n\n\n\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\n\n['a', 'b', 'c', 'd', 'e']\n\n\n\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\n\n['a', 'b', 'c', 'd', 'e']\n\n\nAssim como já explicamos, uma lista é uma sequência de valores e uma string é uma sequência de caracteres, mas uma lista de caracteres não é a mesma coisa que uma string. Para converter uma string em uma lista de caracteres, você pode usar o comando list:\n\ns = 'spam'\nt = list(s)\nprint(t)\n\n['s', 'p', 'a', 'm']\n\n\nA função list quebra uma string em letras individuais. Se você quiser quebrar uma string em palavras, você pode usar o método split(). Esse método admite um argumento adicional, chamado delimiter, que especifica quais caracteres podem ser usados para demonstrar os limites das palavras. Isso é muito útil, por exemplo, quando queremos separar um texto em palavras e fazer a contagem de palavras que mais se repetem. Qual caracter deveríamos passar como argumento em split() nesse caso?\n\ns = 'pining for the fjords'\nt = s.split(' ')\nprint(t)\n\n['pining', 'for', 'the', 'fjords']\n\n\n\ns = 'spam-spam-spam'\nt = s.split('-')\nt\n\n['spam', 'spam', 'spam']\n\n\nO método join() é o contrário de split(). Ele toma uma lista de strings e concatena os elementos. join(), no entanto, é um método de string, então é preciso invocá-lo no string delimitador (por exemplo, ” - “) e passar a lista de strings como parâmetro:\n\nt = ['spam','spam','spam']\ns = ' - '.join(t)\nprint(s)\n\nspam - spam - spam\n\n\nAlém desses principais, existem outros vários métodos para listas. Esse link é um bom ponto de partida para quem quiser conhecer outros exemplos.\n\n\n4.2.3 Operadores lógicos e variáveis booleanas\nAgora faremos um pequeno desvio, que será bem útil daqui para frente, para falar de expressões e variáveis booleanas. Em resumo, uma expressão booleana é uma expressão que pode ser verdadeira ou falsa e dessa forma assumir apenas dois valores como resultado: True e False. Os exemplos seguintes usam o operador de igual no Python (==) que compara dois operandos e produz True se forem iguais e False se não forem:\n\n5 == 5\n\nTrue\n\n\n\n5 == 6\n\nFalse\n\n\n\nlista1 = [1,2,3,4,5]\nlista2 = [5,4,3,2,1]\n\nlista1 == lista2\n\nFalse\n\n\nTrue e False são valores especiais que pertencem ao tipo bool; não são strings. Além disso, é possível fazer operações aritméticas com variáveis do tipo bool já que o Python entende True como sendo equivalente ao número 1 e False como sendo equivalente ao número 0.\n\nprint(type(True))\nprint(type(False))\n\n&lt;class 'bool'&gt;\n&lt;class 'bool'&gt;\n\n\n\nprint(True + True)\nprint(True + False)\nprint(False + False)\n\n2\n1\n0\n\n\nO operador == é um dos operadores relacionais dentro do Python, os outros são:\n\nx != y: x não é igual a y\nx &gt; y: x é maior que y\nx &lt; y: x é menor que y\nx &gt;= y: x é maior ou igual a y\nx &lt;= y: x é menor ou igual a y\n\nEmbora essas operações provavelmente sejam familiares para você, os símbolos do Python são diferentes dos símbolos matemáticos. Um erro comum é usar apenas um sinal de igual (=) em vez de um sinal duplo (==). Lembre-se de que = é um operador de atribuição e == é um operador relacional. Não existe =&gt; ou =&lt;.\nHá três operadores lógicos: and, or e not. A semântica (significado) destes operadores é semelhante ao seu significado em inglês. Por exemplo, x&gt;=0 and x&lt;=10 só é verdade se x for maior que 0 e menor que 10. n%2 == 0 or n%3 == 0 é verdadeiro se uma ou as duas condição(ões) for(em) verdadeira(s), isto é, se o número n for divisível por 2 ou 3 (caso você não esteja familiarizado com a divisão pelo piso e o operador módulo, tente brincar um pouco com // e com %). Finalmente, o operador not nega uma expressão booleana, então not (x &gt; y) é verdade se x &gt; y for falso, isto é, se x for menor que ou igual a y.\nFalando estritamente, os operandos dos operadores lógicos devem ser expressões booleanas, mas o Python não é muito estrito. Qualquer número que não seja zero é interpretado como True:\n\n42 and True\n\nTrue\n\n\nEsta flexibilidade tem sua utilidade, mas há algumas sutilezas relativas a ela que podem ser confusas. Assim, pode ser uma boa ideia evitá-la (a menos que você tenha certeza absoluta do que está fazendo).\n\n\n4.2.4 Execução condicional\nPara escrever programas úteis, quase sempre precisamos da capacidade de verificar condições e mudar o comportamento do programa de acordo com elas. Instruções condicionais nos dão esta capacidade. A forma mais simples é a instrução if:\n\nx=5\n\nif x &gt; 0:\n    print('x é positivo')\n\nx é positivo\n\n\nA expressão booleana depois do if é chamada de condição. Se for verdadeira, a instrução indentada é executada. Se não, nada acontece. Aqui vale mais um adendo: uma característica muito importante da sintaxe do Python é justamente a identação. Diferentemente de outras linguagens de programação, a identação exerce papel importante aqui, já que é através dela que se determina onde se inicia e onde termina um bloco de código, que pode ser uma expressão condicional ou mesmo uma função, como veremos mais a frente. Além de economizar várias chaves (“{” e “}”) e vários “end”, a identação exerce um papel estético importante ao permitir uma melhor visualização do código como um todo.\nNão há limite para o número de instruções que podem aparecer no corpo de uma instrução if, mas deve haver pelo menos uma. Ocasionalmente, é útil ter um corpo sem instruções (normalmente como um espaço reservado para código que ainda não foi escrito). Neste caso, você pode usar a instrução pass, que não faz nada.\n\nif x &lt; 0:\n    pass \n\n\n\n4.2.5 Execução alternativa\nUma segunda forma da instrução if é a “execução alternativa”, na qual há duas possibilidades e a condição determina qual será executada. A sintaxe pode ser algo assim:\n\nx = 5\n\nif x % 2 == 0:\n    print('x é par')\nelse:\n    print('x é ímpar')\n\nx é ímpar\n\n\nSe o resto quando x for dividido por 2 for 0, então sabemos que x é par e o programa exibe uma mensagem adequada. Se a condição for falsa, o segundo conjunto de instruções é executado. Como a condição deve ser verdadeira ou falsa, exatamente uma das alternativas será executada. As alternativas são chamadas de ramos (branches), porque são ramos no fluxo da execução.\nPodemos usar a instrução if para testar o tamanho de uma lista também:\n\nlista1 = [1,2,3,4,5]\n\nif len(lista1) &gt; 2:\n    print('lista1 tem mais de dois elementos')\nelse:\n    print('lista1 tem menos de dois elementos')\n\nlista1 tem mais de dois elementos\n\n\n\n\n4.2.6 Condicionais encadeadas\nÀs vezes, há mais de duas possibilidades e precisamos de mais que dois ramos. Esta forma de expressar uma operação de computação é uma condicional encadeada:\n\nx = 5\ny = 6\n\nif x &lt; y:\n    print('x é menor do que y')\nelif x &gt; y:\n    print('x é maior do que y')\nelse:\n    print('x e y são iguais')\n\nx é menor do que y\n\n\nelif é uma abreviatura de “else if”. Novamente, exatamente um ramo será executado. Não há nenhum limite para o número de instruções elif. Se houver uma cláusula else, ela deve estar no fim, mas não é preciso haver uma. Cada condição é verificada em ordem. Se a primeira for falsa, a próxima é verificada, e assim por diante. Se uma delas for verdadeira, o ramo correspondente é executado e a instrução é encerrada. Mesmo se mais de uma condição for verdade, só o primeiro ramo verdadeiro é executado.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#tuplas",
    "href": "objetos.html#tuplas",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "4.3 Tuplas",
    "text": "4.3 Tuplas\nAgora falaremos de mais um tipo de objeto básico do Python, a tupla. Uma tupla é uma sequência de valores. Os valores podem ser de qualquer tipo, e podem ser indexados por números inteiros, portanto, nesse sentido, as tuplas são muito parecidas com as listas. A diferença importante é que as tuplas são imutáveis, assim como os strings.\nEm resumo, uma tupla é uma lista de valores separados por vírgulas e em geral delimitado por parênteses (lembre que listas são delimitadas por colchetes):\n\nt = ('a', 'b', 'c', 'd', 'e')\n\nprint(type(t))\n\n&lt;class 'tuple'&gt;\n\n\nUm único valor entre parênteses não é uma tupla. Para criar uma tupla com um único elemento, é preciso incluir uma vírgula final após o elemento, com ou sem os parênteses.\n\nt1 = ('a')\nt2 = 'a',\nt3 = ('a',)\n\nprint(type(t1))\nprint(type(t2))\nprint(type(t3))\n\n&lt;class 'str'&gt;\n&lt;class 'tuple'&gt;\n&lt;class 'tuple'&gt;\n\n\nOutra forma de criar uma tupla é com a função integrada tuple. Sem argumentos, cria uma tupla vazia. Se os argumentos forem uma sequência (string, lista ou tupla), o resultado é uma tupla com os elementos da sequência:\n\nt = tuple()\nprint(t)\n\n()\n\n\n\nt = tuple('lupins')\nprint(t)\n\n('l', 'u', 'p', 'i', 'n', 's')\n\n\n\n4.3.1 Operações básicas\nA maior parte dos operadores de lista também funciona em tuplas. O operador de colchetes indexa um elemento e o operador de fatia seleciona vários elementos.\n\nt = ('a', 'b', 'c', 'd', 'e')\nprint(t[0])\nprint(t[1:3])\n\na\n('b', 'c')\n\n\nEntretanto, se tentar alterar um dos elementos da tupla, vai receber um erro:\n\nt[0] = 'A'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[58], line 1\n----&gt; 1 t[0] = 'A'\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nComo tuplas são imutáveis, você não pode alterar os elementos, mas pode substituir uma tupla por outra.\n\nt = ('A',) + t[1:]\nprint(t)\n\n('A', 'b', 'c', 'd', 'e')\n\n\nOs operadores relacionais funcionam com tuplas e outras sequências. O Python começa comparando o primeiro elemento de cada sequência. Se forem iguais, vai para os próximos elementos, e assim por diante, até que encontre elementos que sejam diferentes. Os elementos subsequentes não são considerados (mesmo se forem muito grandes).\n\n(0, 1, 2) &lt; (0, 3, 4)\n\nTrue\n\n\n\n(0, 1, 2000000) &lt; (0, 3, 4)\n\nTrue\n\n\n\n\n4.3.2 Atribuição de tuplas\nMuitas vezes, é útil trocar os valores de duas variáveis. Com a atribuição convencional, é preciso usar uma variável temporária. Por exemplo, trocar a e b.\n\na=5\nb=6\n\ntemp = a\na = b\nb = temp\n\nprint(b)\n\n5\n\n\nEssa solução é trabalhosa; a atribuição de tuplas é mais elegante:\n\na=5\nb=6\n\na, b = b, a\n\nprint(b)\n\n5\n\n\nO lado esquerdo é uma tupla de variáveis e o lado direito é uma tupla de expressões. Cada valor é atribuído à sua respectiva variável. Todas as expressões no lado direito são avaliadas antes de todas as atribuições.\nO número de variáveis à esquerda e o número de valores à direita precisam ser iguais:\n\na, b = 1, 2, 3\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[64], line 1\n----&gt; 1 a, b = 1, 2, 3\n\nValueError: too many values to unpack (expected 2)\n\n\n\nDe forma geral, o lado direito pode ter qualquer tipo de sequência (string, lista ou tupla). Por exemplo, para dividir um endereço de email em um nome de usuário e um domínio, você poderia escrever:\n\naddr = 'monty@python.org'\nuname, domain = addr.split('@')\n\nO valor de retorno do split() é uma lista com dois elementos; o primeiro elemento é atribuído a uname, o segundo a domain:\n\nprint(uname)\nprint(domain)\n\nmonty\npython.org\n\n\n\n\n4.3.3 Tuplas como valores de retorno\nFalando estritamente, uma função só pode retornar um valor, mas se o valor for uma tupla, o efeito é o mesmo que retornar valores múltiplos. Por exemplo, se você quiser dividir dois números inteiros e calcular o quociente e resto, não é eficiente calcular x/y e depois x%y. É melhor calcular ambos ao mesmo tempo. A função integrada divmod toma dois argumentos e devolve uma tupla de dois valores: o quociente e o resto da divisão do primeiro termo pelo segundo termo. Você pode guardar o resultado como uma tupla:\n\nprint(7//3)\nprint(7%3)\n\n2\n1\n\n\n\nt = divmod(7, 3)\n\nprint(t)\nprint(type(t))\n\n(2, 1)\n&lt;class 'tuple'&gt;\n\n\n\n\n4.3.4 Operações nativas com tuplas\nzip é uma função integrada que recebe duas ou mais sequências e devolve uma lista de tuplas onde cada tupla contém um elemento de cada sequência. O nome da função tem a ver com o zíper, que se junta e encaixa duas carreiras de dentes.\nEste exemplo encaixa uma string e uma lista:\n\ns = 'abc'\nt = [0, 1, 2]\nzip(s,t)\n\n&lt;zip at 0x1f4ef5d5580&gt;\n\n\nO resultado é um objeto zip que sabe como percorrer os pares. O uso mais comum de zip é em um loop for (falaremos sobre loops mais adiante no curso):\n\nfor pair in zip(s, t):\n    print(pair)\n\n('a', 0)\n('b', 1)\n('c', 2)\n\n\nUm objeto zip é um tipo de iterador, ou seja, qualquer objeto que percorre ou itera sobre uma sequência. Iteradores são semelhantes a listas em alguns aspectos, mas, ao contrário de listas, não é possível usar um índice para selecionar um elemento de um iterador. Se quiser usar operadores e métodos de lista, você pode usar um objeto zip para fazer uma lista:\n\nlist(zip(s, t))\n\n[('a', 0), ('b', 1), ('c', 2)]\n\n\nO resultado é uma lista de tuplas. Neste exemplo, cada tupla contém um caractere da string e o elemento correspondente da lista. Se as sequências não forem do mesmo comprimento, o resultado tem o comprimento da mais curta:\n\nlist(zip('Anne', 'Elk'))\n\n[('A', 'E'), ('n', 'l'), ('n', 'k')]",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#dicionários",
    "href": "objetos.html#dicionários",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "4.4 Dicionários",
    "text": "4.4 Dicionários\nDicionários são um outro tipo de objeto bastante importante e útil em nossas aplicações. Dicionários são um dos melhores recursos do Python, eles são os blocos de montar de muitos algoritmos eficientes e elegantes.\nUm dicionário se parece com uma lista, mas é mais geral. Em uma lista os índices têm que ser números inteiros, em um dicionário eles podem ser de (quase) qualquer tipo. Um dicionário contém uma coleção de índices, que se chamam chaves e uma coleção de valores. Cada chave é associada com um único valor. A associação de uma chave e um valor chama-se par chave-valor ou item.\nEm linguagem matemática, um dicionário representa um mapeamento de chaves a valores, para que você possa dizer que cada chave “mostra o mapa” a um valor. Como exemplo, vamos construir um dicionário que faz o mapa de palavras do inglês ao espanhol, portanto as chaves e os valores são todos strings.\nA função dict cria um novo dicionário sem itens. Como dict é o nome de uma função integrada, você deve evitar usá-lo como nome de variável.\n\neng2sp = dict()\neng2sp\n\n{}\n\n\nAs chaves {} representam um dicionário vazio. Para acrescentar itens ao dicionário, você pode usar colchetes:\n\neng2sp['one'] = 'uno'\n\nEsta linha cria um item que mapeia da chave ‘one’ ao valor ‘uno’. Se imprimirmos o dicionário novamente, vemos um par chave-valor com dois pontos entre a chave e o valor:\n\neng2sp\n\n{'one': 'uno'}\n\n\nEste formato de saída também é um formato de entrada. Por exemplo, você pode criar um dicionário com três itens:\n\neng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\neng2sp\n\n{'one': 'uno', 'two': 'dos', 'three': 'tres'}\n\n\nUé, mas a ordem parece diferente daquela que definimos, não? Se você digitar o mesmo exemplo no seu computador, pode receber um resultado diferente. Em geral, a ordem dos itens em um dicionário é imprevisível. No entanto, isso não é um problema porque os elementos de um dicionário nunca são indexados com índices de números inteiros. Em vez disso, você usa as chaves para procurar os valores correspondentes. A chave 'two', por exemplo sempre mapeia ao valor 'dos', assim a ordem dos itens não importa.\n\neng2sp['two']\n\n'dos'\n\n\nSe a chave não estiver no dicionário, você recebe uma exceção:\n\neng2sp['four']\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[78], line 1\n----&gt; 1 eng2sp['four']\n\nKeyError: 'four'\n\n\n\nAssim como em strings e listas, a função len também é compatível com dicionários. Nesse caso ela devolve o número de pares chave-valor.\n\nlen(eng2sp)\n\n3\n\n\nO operador in funciona em dicionários também. Ele acusa se algo aparece como chave no dicionário (aparecer como valor não é o suficiente).\n\n'one' in eng2sp\n\nTrue\n\n\n\n'uno' in eng2sp\n\nFalse\n\n\nPara ver se algo aparece como um valor em um dicionário, você pode usar o método values(), que devolve uma coleção de valores, e então usar o operador in:\n\nvals = eng2sp.values()\n'uno' in vals\n\nTrue\n\n\n\n4.4.1 Operações básicas\nPodemos adicionar um novo par de chave e valor ao dicionário usando colchetes, mas caso a chave já exista no dicionário, podemos atualizar o valor.\n\ny = {}\ny['one'] = 1\ny['two'] = 2\nprint(y)\n\n{'one': 1, 'two': 2}\n\n\n\ny['two'] = 'dos'\nprint(y)\n\n{'one': 1, 'two': 'dos'}\n\n\nO valor-chave deve ser um tipo de dados imutável, por essa razão, se você tentar definir um dicionário com um tipo de dados mutável, o Python levantará um erro de exceção.\nA instrução del pode ser usada para remover uma entrada (par de valor de chave) de um dicionário.\n\ny = {'one': 1, 'two': 2}\nprint(y)\n\n{'one': 1, 'two': 2}\n\n\n\ndel y['two']\nprint(y)\n\n{'one': 1}\n\n\nMais uma vez, podemos utilizar a função nativa len para retornar o número de entradas (pares de valor de chave) em um dicionário.\n\nx = {'one': 0, 'two': 2}\nprint(len(x))\n\n2\n\n\nTente acessar uma chave que não está em um dicionário e você receberá um erro de exceção do Python. Para lidar com essa exceção, você pode usar mais uma vez o operador in que testa se existe uma chave em um dicionário. Esse operador retorna True se o dicionário tiver um valor armazenado sob a chave fornecida e Falso caso contrário.\n\ny = {'one': 1, 'two': 2}\ndel y['three']\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[88], line 2\n      1 y = {'one': 1, 'two': 2}\n----&gt; 2 del y['three']\n\nKeyError: 'three'\n\n\n\n\n'three' in y\n\nFalse\n\n\n\n\n4.4.2 Métodos de dicionários\nDentre os principais métodos aplicáveis a dicionários e suas funcionalidades podemos citar: \n\ndict_example.update(x): atualiza o dicionário “dict_example” com todos os pares de valor-chave de um segundo dicionário “x”. Os valores de chaves, que são comuns a ambos os dicionários, do segundo dicionário irão se sobrepor aos valores das chaves do primeiro dicionário. \ndict_example.keys(x): permite que você obtenha todas as chaves no dicionário. Muitas vezes é usado dentro de uma série de instruções repetida várias vezes para iterar sobre o conteúdo de um dicionário. \ndict_example.items(): retorna todas as chaves do dicionário “dict_example” e seus valores associados como uma sequência de tuplas. \ndict_example.get(x,y): devolve o valor associado a uma chave “x” se o dicionário contiver essa chave. Caso o dicionário não contenha a chave, você pode especificar um segundo argumento opcional “y” para retornar um valor padrão (se o argumento não estiver incluído o método retornará None). \ndict_example.setdefault(x,y): é semelhante ao método get(): ele retorna o valor associado a uma chave “x” se o dicionário contiver essa chave, mas caso o dicionário não contenha a chave, este método criará um novo elemento no dicionário (par de valor de chave), onde o primeiro argumento neste método é a chave, e o segundo argumento (“y”) é o valor. O segundo argumento é opcional, mas se isso não for incluído, o valor atrelado a essa nova chave será None. \n\nAlém desses principais, existem outros vários métodos para dicionários. Esse link é um bom ponto de partida para quem quiser conhecer outros exemplos.\n\nx = {'one': 0, 'two': 2}\ny = {'one': 1, 'three': 3}\nprint(x)\n\nx.update(y)\nprint(x)\n\n{'one': 0, 'two': 2}\n{'one': 1, 'two': 2, 'three': 3}\n\n\n\nx = {'one': 1, 'two': 2}\nprint(x.keys())\n\ndict_keys(['one', 'two'])\n\n\n\nx = {'one': 1, 'two': 2}\nprint(x.items())\n\ndict_items([('one', 1), ('two', 2)])\n\n\n\ny = {'one': 1, 'two': 2}\nprint(y.get('one'))\nprint(y.get('three'))\nprint(y.get('three', 'The key does not exist.'))\n\n1\nNone\nThe key does not exist.\n\n\n\ny = {'one': 1, 'two': 2}\nprint(y.setdefault('three', '3'))\nprint(y.setdefault('two', 'dos'))\nprint(y)\n\n3\n2\n{'one': 1, 'two': 2, 'three': '3'}\n\n\n\nprint(y.setdefault('four'))\nprint(y)\n\nNone\n{'one': 1, 'two': 2, 'three': '3', 'four': None}",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#exercícios",
    "href": "objetos.html#exercícios",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "4.5 Exercícios",
    "text": "4.5 Exercícios\n\nConsidere a seguinte lista: fruit = ['pear', 'orange', 'apple', 'grapefruit', 'apple', 'pear']. Use uma função de lista para dizer o índice da primeira ocorrência de apple\nUsando a lista do exercício anterior, use uma função de lista para retornar o número de veze que apple ocorre.\nExistem duas listas abaixo. Escreva um programa que as converta em um dicionário em que o item de keys é a chave e o item de values é o valor\n\n\nkeys = ['Ten', 'Twenty', 'Thirty']\nvalues = [10, 20, 30]\n\nOutput esperado do último exercício\n\n{'Ten': 10, 'Twenty': 20, 'Thirty': 30}\n\n{'Ten': 10, 'Twenty': 20, 'Thirty': 30}",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "iteracao.html",
    "href": "iteracao.html",
    "title": "5  Controle de fluxo e iteração",
    "section": "",
    "text": "5.1 Repetição simples e a instrução for\nX bla bla bla\nOs computadores muitas vezes são usados para automatizar tarefas repetitivas. A repetição de tarefas idênticas ou semelhantes sem cometer erros é algo que os computadores fazem muito bem e as pessoas não. Em um programa de computador, a repetição também é chamada de iteração.\nDe maneira um pouco mais formal, iteração significa executar o mesmo bloco de código repetidamente, potencialmente muitas vezes. Uma estrutura de programação que implementa a iteração é chamada de loop. A forma mais simples de iteração é a chamada iteração definida, em que o número de vezes que o bloco designado será executado é especificado explicitamente no momento em que o loop é iniciado.\nPara atingir o objetivo proposto pela iteração definida utilizaremos no Python a instrução for. Um loop for tem duas partes: um cabeçalho especificando a iteração, que termina em dois pontos, e um corpo identado que é executado uma vez por iteração. O corpo pode conter qualquer número de instruções, mas o Python só reconhecerá como parte do corpo o código que estiver identado em relação ao cabeçalho.\nNo Python o for tem a cara abaixo\nNote que &lt;objeto&gt; em geral se refere à uma sequência, seja ela uma lista, uma tupla, um string ou qualquer outro objeto pelo qual seja possível percorrer. Para cada &lt;elemento&gt; dentro da sequência &lt;objeto&gt; o conjunto de instruções em &lt;instruções&gt;será executado. Após percorrer todos os elementos pertencentes à sequência &lt;objeto&gt;, o Python para a execução do loop.\nAntes de partir para os exemplos, porém, vamos dar um passo atrás e falar mais sobre algo que apenas citamos algumas aulas atrás que é a importação de bibliotecas de comando e de conjuntos de funções que não estão contidas nas funções e operações nativas do Python.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Controle de fluxo e iteração</span>"
    ]
  },
  {
    "objectID": "iteracao.html#repetição-simples-e-a-instrução-for",
    "href": "iteracao.html#repetição-simples-e-a-instrução-for",
    "title": "5  Controle de fluxo e iteração",
    "section": "",
    "text": "for &lt;elemento&gt; in &lt;objeto&gt;:\n    &lt;instruções&gt;\n\n\n\n5.1.1 Importando bibliotecas de comandos e conjuntos de funções\nSempre que quisermos trazer algo “de fora”, devemos carregar as bibliotecas específicas, seja por completo ou apenas um subconjunto de suas funções. Fazemos isso por meio do comando import. Vamos utilizar como exemplo a biblioteca NumPy, uma das principais bibliotecas de comando do Python em se tratando de operações algébricas e matriciais.\nDedicaremos uma aula inteira para trabalhar com o NumPy daqui algumas semanas, mas por hora trabalharemos apenas com as funções geradoras de números aleatórios, em especial a função geradora de números aleatórios distribuídos de acordo com uma Distribuição Uniforme padrão (vocês devem se lembrar das características dessa distribuição das aulas de estatística, mas caso ainda restem dúvidas sempre existe o Wikipedia).\nHá 3 formas de trabalhar com essa função específica, contida no NumPy:\n\n\nPodemos importar a biblioteca inteira\n\n\nimport numpy\n\n\nPodemos importar a biblioteca inteira mas dando-lhe um “apelido”\n\n\nimport numpy as np\n\n\nPodemos importar apenas a função que nos interessa nesse caso\n\n\nfrom numpy.random import uniform\n\n\nQual a diferença entre esses métodos? No Python, sempre que formos utilizar uma função de algum pacote “de fora” é preciso dizer ao Python de onde que essa função está vindo. Se quisermos usar a função uniform() através do 1º método, por exemplo, é preciso chamá-la utilizando o nome do pacote, nesse caso numpy.random.uniform(). O 2º método encurta esse nome de tal forma que é possível chamar a mesma função usando np.random.uniform(). Por fim, no 3º caso basta chamar a função diretamente, isto é, uniform().\nMas se o 3º caso é mais direto, porque não usá-lo sempre? Por duas razões bem simples: (i) usar a sintaxe dos 2 primeiros casos torna o código mais compreensível e depurável, já que no caso de algum problema de execução sabemos onde procurar a resposta, e (ii) é comum pacotes distintos usarem o mesmo nome para funções que fazem operações distintas, o que pode gerar problemas de incompatibilidade e/ou de executarmos algo diferente daquilo que gostaríamos de executar.\nNa maioria das vezes, acabamos utilizando o 2º método, já que isso permite reduzir linhas desnecessárias de código ao mesmo tempo que facilita a replicabilidade e a atividade de depuração do código.\nVoltemos então ao nosso exercício de gerar números aleatórios uniformemente distribuídos:\n\nimport numpy as np\n\nImagine agora que estejamos interessados em criar um for loop que printa 10 números aleatórios sorteados de uma distribuição uniforme que vai de 0 a 1. Utilizando o objeto range() e a lógica de listas:\n\nprint(range(0,10))\n\nrange(0, 10)\n\n\n\nprint(list(range(0,10)))\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nfor i in list(range(0,10)):\n    \n    u = np.random.uniform()\n    print(u)\n\n0.358398878980405\n0.1598714966824758\n0.4728110161027661\n0.8636410373239501\n0.4322979787637966\n0.9715595379317318\n0.19638364283588283\n0.3680489581070784\n0.5757163051171602\n0.13658020928484738\n\n\nNo loop acima não utilizamos o elemento i em nenhum momento, de modo que a lista nos serviu apenas para ditar o número de vezes que gostaríamos de rodar o bloco de instruções abaixo do cabeçalho, no caso 10. Podemos ir um pouco além.\n\nfor i in list(range(0,10)):\n    \n    u = np.random.uniform()\n    print('Essa é a iteração '+str(i+1)+' e o número sorteado foi: {:.2f}'.format(u)) \n\nEssa é a iteração 1 e o número sorteado foi: 0.52\nEssa é a iteração 2 e o número sorteado foi: 0.20\nEssa é a iteração 3 e o número sorteado foi: 0.97\nEssa é a iteração 4 e o número sorteado foi: 0.41\nEssa é a iteração 5 e o número sorteado foi: 0.08\nEssa é a iteração 6 e o número sorteado foi: 0.20\nEssa é a iteração 7 e o número sorteado foi: 0.32\nEssa é a iteração 8 e o número sorteado foi: 0.88\nEssa é a iteração 9 e o número sorteado foi: 0.81\nEssa é a iteração 10 e o número sorteado foi: 0.86\n\n\nNote que nesse caso utilizamos tanto o elemento iterável i, quanto o resultado de cada sorteio individual u.\nComo dito anterioremente, o loop for funciona com qualquer sequência ou objeto pelo qual seja possível percorrer. Podemos trabalhar, inclusive, com strings e listas como nos exemplos abaixo:\n\nstr1 = 'Vou nadaaaa'\n\nfor c in str1:\n    print(c)\n\nV\no\nu\n \nn\na\nd\na\na\na\na\n\n\n\nlista1 = ['Minha terra tem palmeiras','onde canta o sabiá','seno A cosseno B','seno B cosseno A']\n\nfor f in lista1:\n    print(f)\n\nMinha terra tem palmeiras\nonde canta o sabiá\nseno A cosseno B\nseno B cosseno A\n\n\n\n\n5.1.2 for loop e instruções condicionais\nPodemos utilizar instruções condicionais dentro de um loop for também. Mais do que isso, é possível utilizar esse tipo de instrução para interromper a repetição do código, mesmo antes do Python percorrer todos os elementos da sequência alvo.\n\nfor i in ['foo','bar','baz','qux']:\n    \n    if 'b' in i:\n        break\n    print(i)\n\nfoo\n\n\nNote que no caso acima, o segundo elemento da lista ['foo','bar','baz','qux'] contém a letra ‘b’ mas o primeiro não. A instrução if, portanto, retorna False na primeira iteração e True na segunda. No momento em que ela retorna True o código identado break é executado e o loop para aí! Dessa forma, o único termo que a instrução print vai imprimir será o primeiro da lista, isto é, ‘foo’.\n\n\n5.1.3 Exercício de fixação\n\nO último teorema de Fermat diz que não há nenhum número inteiro positivo a,b,c tal que\n\\[ a^n + b^n = c^n \\]\npara quaisquer valores de n maiores do que 2.\nUse o que você aprendeu com condicionais, operações aritméticas e instruções print para testar se o teorema se mantém, dada a lista de números inteiros abaixo. Note que ao fim de cada iteração, o programa deve exibir “Holy smokes! Fermat was wrong” caso o teorema não valha e “Fermat was right” caso você não tenha refutado um gênio dos tempos modernos.\na = [1,2,3,4,5,6,7,8,9,10]\nb = [1,2,3,4,5,6,7,8,9,10]\nn = [3,4,5,6,7,8,9,10,37,52,89,100]\n\n\n5.1.4 Usando enumerate e zip\nÀs vezes pode ser útil, dentro de um loop for, ter uma variável que muda em cada iteração do loop que possibilite fazer um controle mais direto sobre qual iteração está sendo executada em determinado momento. Em vez de criar e incrementar uma variável você mesmo, você pode usar a função nativa enumerate() para obter um contador e o valor do objeto iterável ao mesmo tempo! Para deixar claro como funciona a sintaxe nesse caso, vamos trabalhar em cima de uma lista de strings.\n\nstr1 = 'O Tata é foota, o Tata é foota'\n\n# Algumas linhas de código adicionais para excluir pontuação e transformar o string em uma lista de palavras\nstr1 = str1.replace('.','')\nstr1 = str1.replace(',','')\nstr1 = str1.replace('?','')\nlista1 = str1.split()\n\nfor c in lista1:\n    print(c)\n\nO\nTata\né\nfoota\no\nTata\né\nfoota\n\n\nUtilizando o enumerate() podemos, em uma mesma linha de código, printar não apenas cada string individual da lista, mas também a posição desse string dentro da lista!\n\nfor count,value in enumerate(lista1):\n    \n    print('Elemento '+str(count)+' = '+value)\n\nElemento 0 = O\nElemento 1 = Tata\nElemento 2 = é\nElemento 3 = foota\nElemento 4 = o\nElemento 5 = Tata\nElemento 6 = é\nElemento 7 = foota\n\n\nUma outra forma de criar esses mesmos resultados seria utilizando a função nativa zip(). Essa função nos permite iterar ao longo de duas ou mais sequências ao mesmo tempo, contanto que as sequências possuam o mesmo comprimento.\n\nprint(lista1)\n\n['O', 'Tata', 'é', 'foota', 'o', 'Tata', 'é', 'foota']\n\n\n\nlista2 = list(range(0,len(lista1)))\nprint(lista2)\n\n[0, 1, 2, 3, 4, 5, 6, 7]\n\n\n\nlen(lista1) == len(lista2)\n\nTrue\n\n\n\nfor count,value in zip(lista2, lista1):\n    \n    print('Elemento '+str(count)+' = '+value)\n\nElemento 0 = O\nElemento 1 = Tata\nElemento 2 = é\nElemento 3 = foota\nElemento 4 = o\nElemento 5 = Tata\nElemento 6 = é\nElemento 7 = foota\n\n\nEmbora tenhamos utilizado a função zip() para chegar ao mesmo resultado de enumerate(), seu escopo de ação é muito mais geral já que nos permite percorrer dois objetos distintos ao mesmo tempo, sejam quais forem esses objetos. A única obrigatoriedade é que esses objetos tenham o mesmo tamanho, nada mais!\n\nprofessores = ['Danilo Souza','Danilo Souza','Claudio Lucinda']\nturmas = ['2024201','2024202','2024221']\n\nfor p,t in zip(professores,turmas):\n    \n    print('Nesse curso, a turma '+t+' é de responsabilidade do professor '+p)\n\nNesse curso, a turma 2024201 é de responsabilidade do professor Danilo Souza\nNesse curso, a turma 2024202 é de responsabilidade do professor Danilo Souza\nNesse curso, a turma 2024221 é de responsabilidade do professor Claudio Lucinda\n\n\n\n\n5.1.5 For e list comprehensions\nList comprehensions é uma das várias formas que o Python nos oferece para de criar, alterar e manipular listas. Sua sintaxe é bastante concisa e nos permite olhar para um exerício de iteração através de algo parecido com uma fórmula.\nImagine que estejamos interessados em criar uma lista que contenha a parte inteira da raiz quadrada de todo número de uma outra lista original. Usualmente faríamos isso utilizando um loop for:\n\nlista1 = [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225]\nlista2 = []\n\nfor x in lista1:\n    lista2.append(int(x**0.5))\n    \nprint(lista2)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n\nAlternativamente, podemos utilizar list comprehensions através da seguinte sintaxe:\n\nlista2 = [int(x**0.5) for x in lista1] \n\nprint(lista2)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n\nEm termos práticos isso funciona como se fosse um loop definido dentro de uma única linha de código. Mas porque aprender as duas formas? Será que alguma delas é mais eficiente? Vamos fazer um teste para esse exercicío da raiz quadrada, porém para uma lista maior. Utilizaremos também a função time do pacote time para calcular o tempo utilizado por cada um dos métodos.\n\nimport time \nlista1 = list(range(1,1000000))\n\n# list comprehension\nstart_comp = time.time()\n\nlist_comp  = [int(x**0.5) for x in lista1]\n\nend_comp   = time.time()\n\n\n# loop\nstart_loop = time.time()\n\nlist_loop = []\nfor x in lista1:\n    list_loop.append(int(x**0.5))  \n    \nend_loop   = time.time()\n\nratio = (start_loop - end_loop) / (start_comp - end_comp)\n\nQual abordagem será que levou menos tempo?\n\nprint('Tempo necessário para a realização dos cálculos utilizando list comprehensions: {:.4f} segundos'.format(end_comp - start_comp))\nprint('Tempo necessário para a realização dos cálculos utilizando loop: {:.4f} segundos'.format(end_loop - start_loop))\nprint('\\nA abordagem de loop demorou {:.1%} mais tempo! Dê uma chance para list comprehensions ;)'.format(ratio - 1))\n\nTempo necessário para a realização dos cálculos utilizando list comprehensions: 0.0909 segundos\nTempo necessário para a realização dos cálculos utilizando loop: 0.1175 segundos\n\nA abordagem de loop demorou 29.3% mais tempo! Dê uma chance para list comprehensions ;)",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Controle de fluxo e iteração</span>"
    ]
  },
  {
    "objectID": "iteracao.html#reatribuição-e-atualização-de-variáveis",
    "href": "iteracao.html#reatribuição-e-atualização-de-variáveis",
    "title": "5  Controle de fluxo e iteração",
    "section": "5.2 Reatribuição e atualização de variáveis",
    "text": "5.2 Reatribuição e atualização de variáveis\nPode ser que você já tenha descoberto que é permitido fazer mais de uma atribuição para a mesma variável. Uma nova atribuição faz uma variável existente referir-se a um novo valor (e deixar de referir-se ao valor anterior).\n\nx = 5\nprint(x)\n\n5\n\n\n\nx = 7\nprint(7)\n\n7\n\n\nA primeira vez que exibimos x, seu valor é 5. Na segunda vez, seu valor é 7.\nNeste ponto quero tratar de uma fonte comum de confusão. Como o Python usa o sinal de igual (=) para atribuição, é tentador interpretar uma afirmação como a = b como uma proposição matemática de igualdade, isto é, a declaração de que a e b são iguais. Mas esta é uma interpretação equivocada.\nEm primeiro lugar, a igualdade é uma relação simétrica e a atribuição não é. Por exemplo, na matemática, se a=7 então 7=a. Mas no Python, a instrução a = 7 é legal e 7 = a não é. Além disso, na matemática, uma proposição de igualdade é verdadeira ou falsa para sempre. Se a=b agora, então a sempre será igual a b. No Python, uma instrução de atribuição pode tornar duas variáveis iguais, mas elas não precisam se manter assim:\n\na = 5\nb = a # a e b agora são iguais\n\nprint('Valor de a: '+str(a)+'\\nValor de b: '+str(b))\n\na = 3 # a e b não são mais iguais\n\nprint('\\nValor de a: '+str(a)+'\\nValor de b: '+str(b))\n\nValor de a: 5\nValor de b: 5\n\nValor de a: 3\nValor de b: 5\n\n\nQuando redefinimos o valor de a para 3, não mudamos o valor de b, de modo que as variáveis deixam de ser iguais. A reatribuição de variáveis muitas vezes é útil, mas você deve usá-la com prudência. Se os valores das variáveis mudarem frequentemente, isso pode dificultar a leitura e depuração do código.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Controle de fluxo e iteração</span>"
    ]
  },
  {
    "objectID": "iteracao.html#repetição-condicional-e-a-instrução-while",
    "href": "iteracao.html#repetição-condicional-e-a-instrução-while",
    "title": "5  Controle de fluxo e iteração",
    "section": "5.3 Repetição condicional e a instrução while",
    "text": "5.3 Repetição condicional e a instrução while\nEm programação existem dois tipos de iteração, indefinidas e definidas:\n\nCom iteração definida, o número de vezes que o bloco designado será executado é especificado explicitamente no momento em que o loop é iniciado. É o exemplo do for loop com o qual trabalhamos anteriormente.\nCom iteração indefinida, o número de vezes que o loop é executado não é especificado explicitamente com antecedência. Em vez disso, o bloco designado é executado repetidamente enquanto alguma condição for atendida.\n\nPara interação indefinida, a construção típica do Python é o while. A forma mais simples desse loop while é a seguinte:\nwhile &lt;expr&gt;:\n    &lt;instruções&gt;\nEm que instruções representam uma ou mais linhas de código a serem executadas. Da mesma forma que nas outras estruturas, a indentação determina quais linhas vão ser executadas.\nA expressão de controle, &lt;expr&gt;, normalmente envolve uma ou mais variáveis que são inicializadas antes de iniciar o loop e depois modificadas em algum lugar no corpo do loop. Você precisa dessa expressão bem pensada, porque é ela que vai determinar o momento em que o loop para\nQuando um loop while é encontrado, &lt;expr&gt;é avaliado primeiro no contexto booleano. Se for verdadeiro, o corpo do loop é executado. Em seguida &lt;expr&gt;, é verificado novamente e, se ainda for verdadeiro, o corpo é executado novamente. Isso continua até &lt;expr&gt; se tornar falso, momento em que a execução do programa prossegue para a primeira instrução além do corpo do loop. Dentro de &lt;instruções&gt; você precisa ter algo que modifique algum elemento de &lt;expr&gt;. Senão ou o loop não vai rodar ou vai rodar para sempre. Uma das formas de interromper à força a execução de um loop é por meio das teclas Ctrl+C.\nConsidere o caso abaixo:\n\nn = 5\n\nwhile n &gt; 0:\n    n = n-1\n    print(n)\n    \nprint('\\nÀ partir de agora as instruções fora do loop serão executadas.')\n\n4\n3\n2\n1\n0\n\nÀ partir de agora as instruções fora do loop serão executadas.\n\n\nVeja o que está acontecendo neste exemplo:\nO valor inicial de n é 5. A expressão no cabeçalho da instrução while na linha 2 é n &gt; 0, o que é True, então o corpo do loop é executado. Dentro do corpo do loop redefinimos o valor de n para que seja igual ao valor anterior de n menos 1, e então o novo valor de n é impresso.\nQuando o corpo do loop termina, a execução do programa retorna ao topo do loop na linha 2 e a expressão é avaliada novamente. Ainda é verdade, então o corpo é executado novamente e 3 é impresso. Isso continua até n se tornar 0. Nesse ponto, quando a expressão é testada, ela é falsa (0 não é maior do que 0) e o loop termina. A execução é retomada na primeira instrução após o corpo do loop, no caso a instrução print. Observe que a expressão de controle do loop while é testada primeiro, antes que qualquer outra coisa aconteça.\nA seguir temos um loop while que usa uma lista:\n\na = ['foo', 'bar', 'baz']\nprint(a)\n\nwhile a:\n    \n    a.pop(-1)\n    print(a)\n\n['foo', 'bar', 'baz']\n['foo', 'bar']\n['foo']\n[]\n\n\nQuando uma lista é avaliada em contexto booleano, ela é verdadeira se tiver elementos nela e falsa se estiver vazia. Neste exemplo, a é verdadeiro desde que tenha elementos nele. Quando todos os itens forem removidos com o método .pop() e a lista estiver vazia, a será falsa e o loop terminará.\n\n5.3.1 Formas de Interromper um Loop\nEm cada exemplo que você viu até agora, todo o corpo do loop while é executado em cada iteração. Python fornece duas palavras-chave que encerram uma iteração de loop prematuramente:\n\nA instrução Python break imediatamente encerra um loop inteiramente. Já vimos como ela funciona no caso do for loop e instruções condicionais.\nA instrução continue, por outro lado, encerra imediatamente a iteração do loop atual. A execução salta para o topo do loop e a expressão de controle é reavaliada para determinar se o loop será executado novamente ou terminará.\n\nUm exemplo de break:\n\nn = 5\nprint(n)\n\nwhile n &gt; 0:\n    n = n - 1\n    if n == 2:\n        break\n    print(n)\n    \nprint('Loop ended.')\n\n5\n4\n3\nLoop ended.\n\n\nUm exemplo de continue:\n\nn = 5\n\nwhile n &gt; 0:\n    n = n - 1\n    if n == 2:\n        continue\n    print(n)\nprint('Loop ended.')\n\n4\n3\n1\n0\nLoop ended.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Controle de fluxo e iteração</span>"
    ]
  },
  {
    "objectID": "iteracao.html#aplicação-teorema-central-do-limite",
    "href": "iteracao.html#aplicação-teorema-central-do-limite",
    "title": "5  Controle de fluxo e iteração",
    "section": "5.4 Aplicação: Teorema Central do Limite",
    "text": "5.4 Aplicação: Teorema Central do Limite\nObs: esse exercício é o mais complexo que fizemos até agora. Nele utilizamos grande parte dos conceitos que estudamos até aqui nesse curso, desde listas a loops e também a importação de bibliotecas de comandos. Você pode pular essa parte por enquanto, mas aconselho que aos poucos você tente replicá-lo, de forma a entender todas suas etapas com o tempo.\n\nO Teorema Central do Limite é um resultado super importante em estatística e com aplicações nas mais diversas áreas. Em sua formulação mais simples, o teorema diz que:\n\nA distribuição da média amostral da variável aleatória \\(X\\) aproxima-se cada vez mais de uma distribuição normal conforme aumenta o tamanho da amostra, independentemente da distribuição original de X.\n\nSuponha que estejamos amostrando de uma variável aleatória X com média finita e igual a \\(\\mu\\) e desvio padrão finito e igual a \\(\\sigma\\). Então média e desvio padrão da distribuição amostral são representados por:\n\\[\\mu_{\\bar{X}}=\\mu\\]\n\\[\\sigma_{\\bar{X}}=\\frac{\\sigma}{\\sqrt{N}}\\]\nVamos apresentar uma implementação desse Teorema usando Python, em várias partes. A primeira parte mostra como tirar 10 números aleatórios entre -40 e 40, usando o NumPy. Mais uma vez utilizaremos a função uniform() já que elas sorteia números reais com igual probabilidade dentro de um intervalo especificado.\n\nimport numpy as np\n\nx = np.random.uniform(-40, 40, 10)\nprint(x)\n\n[ 11.77839937 -25.82722075 -36.1595583   18.47414944  10.8710116\n -21.16278719 -30.10734947 -35.52619771   5.28767077  -6.59570515]\n\n\nNote que se sorteamos 10 números novamente, o resultado será diferente\n\nx = np.random.uniform(-40, 40, 10)\nprint(x)\n\n[-38.81321801 -36.23465309   1.09911783 -25.63149599 -14.30664684\n  10.51712803 -37.82636993 -39.87448865  -1.44957604 -23.44307369]\n\n\nPara tornar o nosso exemplo mais previsível, vamos usar uma função dentro do NumPy que faz com o que o sorteio dos números parta do mesmo lugar e, portanto, o resultado seja o mesmo.\n\nnp.random.seed(1)\n\nx = np.random.uniform(-40, 40, 10)\nprint(x)\n\n[ -6.63823962  17.62595948 -39.99085001 -15.81339419 -28.25952873\n -32.61291242 -25.09918309 -12.35514184  -8.25860206   3.10533872]\n\n\n\nnp.random.seed(1)\n\nx = np.random.uniform(-40, 40, 10)\nprint(x)\n\n[ -6.63823962  17.62595948 -39.99085001 -15.81339419 -28.25952873\n -32.61291242 -25.09918309 -12.35514184  -8.25860206   3.10533872]\n\n\nFeito o sorteio de números aleatórios, o próximo passo é tirar a média desse conjunto de números:\n\nnp.mean(x)\n\nnp.float64(-14.829655377323416)\n\n\nComo vocês podem notar, a média não deu igual a zero, embora a média da distribuição uniforme com números inteiros que vai de -40 a 40 seja igual a 0. E aí surge a mágica do Teorema Central do Limite. Ainda que uma amostra não tenha a média igual à média populacional, a média das médias vai convergindo para zero à medida em que extraímos novas amostras e calculamos novas médias.\nAgora vou fazer isso em um loop, sorteando 50 números aleatórios por amostra e primeiro com 10 amostras:\n\n# number of sample\nn = 10 \nmeans = [] \n\nnp.random.seed(1)\n\nfor j in list(range(0,n)):\n    \n    lista_sorteio = np.random.uniform(-40, 40, 50)\n    x = np.mean(lista_sorteio)\n    means.append(x)\n\nmeans = [np.round(elem,2) for elem in means]\nprint(means)\nnp.mean(means)\n\n[np.float64(-2.64), np.float64(0.38), np.float64(-2.3), np.float64(-0.13), np.float64(3.95), np.float64(4.81), np.float64(1.16), np.float64(0.46), np.float64(-2.02), np.float64(2.95)]\n\n\nnp.float64(0.6619999999999999)\n\n\nAgora com 100 amostras\n\n# number of sample\nn = 100 \nmeans = [] \n\nnp.random.seed(1)\n\nfor j in list(range(0,n)):\n    \n    lista_sorteio = np.random.uniform(-40, 40, 50)\n    x = np.mean(lista_sorteio)\n    means.append(x)\n\nmeans = [np.round(elem,2) for elem in means]\nprint(means)\nnp.mean(means)\n\n[np.float64(-2.64), np.float64(0.38), np.float64(-2.3), np.float64(-0.13), np.float64(3.95), np.float64(4.81), np.float64(1.16), np.float64(0.46), np.float64(-2.02), np.float64(2.95), np.float64(-2.02), np.float64(-1.95), np.float64(-1.69), np.float64(1.3), np.float64(2.67), np.float64(1.64), np.float64(-2.17), np.float64(0.71), np.float64(-3.31), np.float64(-0.82), np.float64(-1.1), np.float64(2.47), np.float64(-0.34), np.float64(1.6), np.float64(0.52), np.float64(-0.78), np.float64(2.61), np.float64(2.68), np.float64(0.98), np.float64(-2.24), np.float64(-4.57), np.float64(5.56), np.float64(2.17), np.float64(3.94), np.float64(4.72), np.float64(3.43), np.float64(2.47), np.float64(2.82), np.float64(1.24), np.float64(0.82), np.float64(0.28), np.float64(-7.24), np.float64(0.77), np.float64(-5.73), np.float64(0.17), np.float64(5.3), np.float64(3.94), np.float64(-8.14), np.float64(-4.17), np.float64(-2.82), np.float64(-1.41), np.float64(-7.05), np.float64(1.03), np.float64(1.15), np.float64(2.35), np.float64(-2.7), np.float64(-3.12), np.float64(0.67), np.float64(-1.7), np.float64(-0.95), np.float64(3.93), np.float64(1.95), np.float64(2.65), np.float64(-2.48), np.float64(-5.42), np.float64(4.43), np.float64(1.88), np.float64(-0.04), np.float64(-1.46), np.float64(1.04), np.float64(-1.54), np.float64(-2.82), np.float64(-2.62), np.float64(-3.85), np.float64(-0.56), np.float64(1.08), np.float64(8.73), np.float64(5.43), np.float64(1.0), np.float64(-3.13), np.float64(-1.05), np.float64(3.14), np.float64(-5.01), np.float64(-1.15), np.float64(-4.29), np.float64(5.22), np.float64(-5.29), np.float64(1.37), np.float64(-8.62), np.float64(-7.99), np.float64(-3.2), np.float64(3.04), np.float64(0.36), np.float64(3.64), np.float64(3.93), np.float64(6.98), np.float64(-1.4), np.float64(-3.84), np.float64(0.81), np.float64(7.0)]\n\n\nnp.float64(0.024600000000000007)\n\n\nVamos deixar essa tentativa de aproximar a média das médias de \\(\\mu\\) mais automatizada:\n\nexpoentes = [1,2,3,4,5,6,7,8,9,10]\nN = [2**exp for exp in expoentes]\n\nmeans = [] \n\nnp.random.seed(1)\nfor n in N:\n    \n    means_atual = [] \n    for j in list(range(0,n)):\n        \n        lista_sorteio = np.random.uniform(-40, 40, 100)\n        x = np.mean(lista_sorteio)\n        means_atual.append(x)\n        \n    means.append(np.mean(means_atual))\n\n\nfor m in means:\n    \n    print(np.round(m,2))\n\n-1.17\n0.92\n0.37\n-0.25\n0.31\n-0.32\n0.23\n-0.15\n-0.06\n0.03\n\n\nOlha só a convergência aí, minha gente!\nNote que até aqui a gente só mostrou que a média das médias converge para a média populacional. O Teorema, no entanto, é mais completo do que isso. Ele diz que a distribuição da média amostral é uma Normal e, além disso, possui aquelas características em relação à distribuição original. Ainda precisamos de mais algumas aulas para ir além e olhar essas outrs questões do Teorema, mas logo logo chegamos lá.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Controle de fluxo e iteração</span>"
    ]
  },
  {
    "objectID": "funcoes.html",
    "href": "funcoes.html",
    "title": "6  Funções",
    "section": "",
    "text": "6.1 O que é uma função?\nIn summary, this book has no content whatsoever.\nNo contexto das linguagens de programação, uma função é uma sequência nomeada de instruções, que executa algum tipo de operação específica mas não necessariamente numérica, como é o caso das funções matemáticas. A ideia essencial por trás de uma função é a de juntar algumas tarefas comuns ou repetidas e criar uma função para que, em vez de escrever o mesmo código várias vezes, possamos chama-la pelo nome e reutilizar o conjunto de instruções nela contida sempre que necessário.\nCaso o objetivo de dividir um programa em funções ainda não tenha ficado claro, saiba que:\nExistem várias funções nativas no Python (e.g., type() para encontrar o tipo de um objeto) e mesmo dentro de bibliotecas com as quais já trabalhamos um pouco (e.g., numpy.random.uniform() para sortear números aleatórios de acordo com uma distribuição uniforme). À partir de agora veremos como podemos criar nossas próprias funções dentro da linguagem!\nNo Python, a sintaxe de uma função é dada por:\nAssim como nos loops, para definir uma nova função no Python é preciso começar com uma palavra-chave, nesse caso def. O nome que daremos à função vem logo em seguida. É através desse nome, nome_da_funcao, que chamaremos essa função em outras partes do nosso código. Entre parênteses definimos os argumentos que a função recebe para realizar o conjunto de instruções em &lt;instruções&gt;.\nNote, mais uma vez, que todo o bloco de código que estiver identado e abaixo da linha de cabeçalho da função fará parte da função. Assim como nos loops, a função termina quando passarmos a primeira linha de código não-identada.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#o-que-é-uma-função",
    "href": "funcoes.html#o-que-é-uma-função",
    "title": "6  Funções",
    "section": "",
    "text": "Criar uma nova função dá a oportunidade de nomear um grupo de instruções, o que deixa o seu programa mais fácil de ler e de depurar\nAs funções podem tornar um programa menor, eliminando o código repetitivo. Depois, caso precise fazer alguma alteração, basta fazê-la em um lugar só.\nDividir um programa longo em funções permite depurar as partes uma de cada vez e então reuni-las em um conjunto funcional.\nAs funções bem projetadas muitas vezes são úteis para muitos programas. Uma vez escritas e depuradas, você pode reutilizar as funções em programas fora daquele para o qual elas foram originalmente construídas.\n\n\n\n\ndef nome_da_funcao(argumentos):\n    &lt;instruções&gt;",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#nossa-primeira-função",
    "href": "funcoes.html#nossa-primeira-função",
    "title": "6  Funções",
    "section": "6.2 Nossa primeira função",
    "text": "6.2 Nossa primeira função\nVamos começar criando uma função simples, que tem por objetivo printar uma das frases mais conhecidas da história do cinema:\n\ndef frase_cinema():\n    print('Que a força esteja com você!')\n\nNote que nesse caso, o parênteses logo após o nome da função está vazio. Isso quer dizer que essa função não recebe argumentos, apenas printa a frase entre aspas sempre que for chamada. Para chamá-la, basta usar o nome frase_cinema seguido dos parênteses vazios:\n\nfrase_cinema()\n\nQue a força esteja com você!",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#argumentos-de-uma-função",
    "href": "funcoes.html#argumentos-de-uma-função",
    "title": "6  Funções",
    "section": "6.3 Argumentos de uma função",
    "text": "6.3 Argumentos de uma função\nNa função anterior, não tínhamos nenhum argumento. Ou seja, toda vez que você chamar a função frase_cinema, ela vai fazer a mesma coisa. Pode até ser que seja o seu objetivo fazer exatamente isso – é uma forma de economizar código.\nO ponto é que a ideia de função é muito mais poderosa do que simplesmente uma “abreviação” de um monte de linhas de código. A abstração implícita no conceito de função é poderosa o suficiente para garantir que a função retorne coisas diferentes caso você altere algum argumento. Vamos falar disso a seguir.\n\n6.3.1 Keyword arguments e default values\nVamos então criar uma função que tenha argumentos.\n\ndef my_func(name,place):\n    print(f\"Olá {name}! Você é de {place}?\")\n\nmy_func(\"Emily\",\"Paris\")\n\nOlá Emily! Você é de Paris?\n\n\nO que acontece se você especificar o place primeiro e depois o name? Vamos descobrir.\n\nmy_func(\"Hawaii\",\"Robert\")\n\nOlá Hawaii! Você é de Robert?\n\n\nMeio bizarro, não? A razão é que aqui temos os chamados argumentos posicionais. Ou seja, a função vai assumir que o primeiro argumento é o name e o segundo é o place não importa o que tenhamos passado como argumento. Para lidar com isso, a gente pode atribuir um nome a cada um dos argumentos, ou palavra-chave, que aí vai ser a palavra-chave, e não a posição, que vai determinar qual o valor atribuído a cada argumento.\n\nmy_func(place=\"Hawaii\",name=\"Robert\")\n\nOlá Robert! Você é de Hawaii?\n\n\nVimos aqui que a posição passou a ser irrelevante porque colocamos os nomes de cada um dos argumentos. E se quiséssemos dar mais flexibilidade ainda à função, só especificando um subconjunto dos argumentos? Para que isso funcione, nós precisamos especificar os valores-padrão dos argumentos caso eles não sejam fornecidos.\nAqui tem uma função que faz isso.\n\ndef total_calc(bill_amount,tip_perc=10):\n    \n    total = bill_amount*(1 + tip_perc/100)\n    total = round(total,2)\n    print(f\"Please pay ${total}\")\n\nNesse caso, o argumento bill_amount é obrigatório. Por outro lado, o argumento tip_perc vai assumir o valor de 10 toda vez que ele não for explicitamente fornecido na chamada da função.\n\n\n6.3.2 Argumentos arbitrários\nVamos começar fazendo algumas perguntas: * E se não soubermos o número exato de argumentos de antemão? * Podemos criar funções que funcionem com um número variável de argumentos?\nA resposta é sim! E vamos criar essa função imediatamente. Vamos criar uma função simples my_var_sum() que retorna a soma de todos os números passados como argumento. No entanto, o número de argumentos pode ser potencialmente diferente cada vez que chamamos a função.\n\ndef my_var_sum(*args):\n    \n    sum = 0\n    for arg in args:\n        sum += arg\n        \n    print(f\"The numbers that you have add up to {sum}\")\n\nObserve como a definição da função agora tem *args em vez de apenas o nome do parâmetro. No corpo da função, fazemos um loop em args até usarmos todos os argumentos. A função my_var_sum retorna a soma de todos os números passados como argumentos. Olha só o que acontece quando chamamos a função com diferentes números de argumentos:\n\nmy_var_sum(99,10,54,23)\nmy_var_sum(9,87)\nmy_var_sum(5,21,36,79,45,65)\nmy_var_sum(1)\n\nThe numbers that you have add up to 186\nThe numbers that you have add up to 96\nThe numbers that you have add up to 251\nThe numbers that you have add up to 1\n\n\nMas e se eu quiser passar não apenas uma sequência de valores, mas uma sequência de valores com nomes? Não se preocupe, existe uma possibilidade de fazer isso, usando o **kwargs na definição dos argumentos. Qual é a diferença entre *args e **kwargs? A diferença é que você vai passar uma sequência de tamanho arbitrário de parâmetros, cada um deles nomeado.\nO Python vai entender o **kwargs como um dicionário. Cada elemento passado é um par chave-valor, e dentro da função você tem que desempacotar o valor da chave. Vamos seguir alguns exemplos.\n\ndef myFun(**kwargs):\n    \n    for key, value in kwargs.items():\n        print(\"%s == %s\" % (key, value))\n \n \nmyFun(first='Geeks', mid='for', last='Geeks')\n\nfirst == Geeks\nmid == for\nlast == Geeks\n\n\nPodemos misturar os tipos de argumentos (posicionais versus *args/*kwargs)? Sim, como podemos ver no exemplo seguinte:\n\ndef myFun(arg1, **kwargs):\n    \n    for key, value in kwargs.items():\n        print(arg1+\" %s == %s\" % (key, value))\n \n \nmyFun(\"Hi - \", first='Geeks', mid='for', last='Geeks')\n\nHi -  first == Geeks\nHi -  mid == for\nHi -  last == Geeks\n\n\n\n\n6.3.3 Elementos dentro da função: execução condicional\nAs funções podem retornar objetos booleanos também, o que pode ser conveniente para esconder testes complicados dentro de funções. Por exemplo:\n\ndef is_divisible(x, y):\n    \n    if x % y == 0:\n        print(True)\n    else:\n        print(False)\n    \nis_divisible(6, 4)\n\nFalse\n\n\n\n\n6.3.4 Aplicação: Teorema Central do Limite - Parte 1\nO primeiro passo para replicarmos, na forma de uma função, a aplicação do Teorema Central do Limite da aula anterior é definir uma função que recebe como argumentos a distribuição da varíavel aleatória X, o intervalo no qual a variável está definida e o número de sorteios que faremos em cada amostra. Com o que aprendemos até agora podemos definir a função func_tcl abaixo:\n\ndef func_tcl(dist=None,intervalo=(0,1),n=100):\n    \n    if dist == None:\n        print('Você esqueceu de carregar uma função que defina a distribuição de X! Volte 2 casas.')\n    else:\n        x = dist(intervalo[0],intervalo[1],n)\n        print(x)\n\nPara todos os 3 argumentos definimos valores default que, caso não sejam alterados a função vai utilizá-los em suas operações. Vamos rodar a função com todos os valores default e ver o que acontece:\n\nfunc_tcl()\n\nVocê esqueceu de carregar uma função que defina a distribuição de X! Volte 2 casas.\n\n\nNesse caso, a execução condicional if dentro da função acende já que não passamos nenhuma distribuição como default, apenas o valor None. Vamos então repetir o que fizemos na aula passada e utilizar a distribuição uniforme, no intervalo \\(\\left[-40,40\\right]\\) e sorteando apenas 10 números desta distribuição:\n\nimport numpy as np\n\nfunc_tcl(dist=np.random.uniform,intervalo=(-40,40),n=10)\n\n[  6.72924359   2.33185979 -21.77714473 -24.60670404 -32.86354772\n -16.08028271  21.67316932 -22.73138889 -26.6675673   38.87163482]\n\n\n\n\n6.3.5 Elementos dentro da função: iteração\nDa mesma forma que podemos ter condições lógicas dentro da função, podemos ter blocos de repetição (for e while) dentro da função, assim como no caso de *args. Vamos olhar para um outro exemplo em que a função recebe uma lista de strings como argumento e faz operações em cada um dos elementos, um a um:\n\nstates = [' Alabama ','Georgia!','Georgia','georgia','FlOrIda','south carolina##','West virginia?']\n\ndef clean_strings(lista_strings):\n    result=[]\n    \n    for value in lista_strings:\n        value = value.strip()\n        value = value.title()\n        value = value.replace('#','')\n        value = value.replace('?','')\n        value = value.replace('!','')\n        result.append(value)\n    \n    print(result)\n\nprint(states)\nprint()\nclean_strings(states)\n\n[' Alabama ', 'Georgia!', 'Georgia', 'georgia', 'FlOrIda', 'south carolina##', 'West virginia?']\n\n['Alabama', 'Georgia', 'Georgia', 'Georgia', 'Florida', 'South Carolina', 'West Virginia']\n\n\n\n\n6.3.6 Aplicação: Teorema Central do Limite - Parte 2\nAgora podemos dar mais um passo e incorporar o loop dentro da função, passando como novo argumento da função o número de amostras com o qual queremos trabalhar:\n\ndef func_tcl(dist=None,intervalo=(0,1),n=100, samples=10):\n    \n    if dist == None:\n        print('Você esqueceu de carregar uma função que defina a distribuição de X!')\n    else:\n        means = []\n        for j in range(0,samples):\n            x_func_tcl = dist(intervalo[0],intervalo[1],n)\n            mean_x = sum(x_func_tcl)/len(x_func_tcl)\n            \n            means.append(mean_x)\n        \n        print('Essa é a lista de médias:')\n        print(means)\n        print('\\nE essa é a média das médias:')\n        print(sum(means)/len(means))\n\n\n# utilizamos a função seed mais uma vez para tornar os resultados previsíveis\nnp.random.seed(1)\n\nfunc_tcl(dist=np.random.uniform,intervalo=(-40,40),n=50,samples=10)\n\nEssa é a lista de médias:\n[np.float64(-2.6419520291841945), np.float64(0.382420445207494), np.float64(-2.2971869003899186), np.float64(-0.12856511296217676), np.float64(3.945331018819081), np.float64(4.808427607983528), np.float64(1.1596981846490986), np.float64(0.4583673137720098), np.float64(-2.0177969126899638), np.float64(2.952952578448611)]\n\nE essa é a média das médias:\n0.662169619365357\n\n\nQue bacana!!!\nMas note que o valor da média que nos interessa nesse caso só aparece printado quando chamamos a função. O que podemos fazer para conseguir guardá-lo como uma nova variável, por exemplo?",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#valor-de-retorno-de-uma-função",
    "href": "funcoes.html#valor-de-retorno-de-uma-função",
    "title": "6  Funções",
    "section": "6.4 Valor de retorno de uma função",
    "text": "6.4 Valor de retorno de uma função\nO comando return é usado para a saída de uma função de volta ao lugar no código de onde ela foi chamada. A sintaxe desse comando é simples:\nreturn &lt;expression_list&gt;\nEssa declaração pode ter um comando que é executado e o valor resultante devolvido. Se esse comando não for anexado ou não tiver nada além do return, a função é devolvida com o valor de None. Por exemplo:\n\ndef my_func(name,place):\n    \n    print(f\"Olá {name}! Você é de {place}?\")\n    return\n\nprint(my_func(\"Jane\",\"Paris\"))\n\nOlá Jane! Você é de Paris?\nNone\n\n\nFunções que não contenham o comando return sempre retornarão um valor vazio. Quando queremos utilizar uma função com o objetivo de realizar algum tipo de operação e guardar o valor dessa operação, não podemos esquecer do return. Vejamos o exemplo da função que calcula a raiz quadrada de um número:\n\ndef raiz(x):\n    \n    fx = x**0.5\n\ny = raiz(100)\nprint(y)\n\nNone\n\n\n\ndef raiz(x):\n    \n    fx = x**0.5\n    return fx\n\ny = raiz(100)\nprint(y)\n\n10.0\n\n\n\n6.4.1 Expectativa de vida de variáveis dentro da função\nQuando você cria uma variável dentro de uma função ela é local, ou seja, só existe dentro da própria função. Por exemplo:\n\ndef concat_strings(str1,str2):\n    \n    texto_concatenado = str1 + ' ' + str2\n    print(texto_concatenado)\n    \n\ntexto1 = 'Que a força esteja com você,'\ntexto2 = 'jovem Padawan.'\n\nconcat_strings(texto1,texto2)\n\nQue a força esteja com você, jovem Padawan.\n\n\nEssa função recebe dois argumentos, concatena-os e exibe o resultado em uma única linha de texto. No entanto, assim que a função é encerrada, a variável texto_concatenado é deletada. O que acontece se tentarmos acessá-la?\n\nprint(texto_concatenado)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[22], line 1\n----&gt; 1 print(texto_concatenado)\n\nNameError: name 'texto_concatenado' is not defined\n\n\n\n\n\n6.4.2 Aplicação: Teorema Central do Limite - Parte 3\nRetomando a função da parte 2:\n\ndef func_tcl(dist=None,intervalo=(0,1),n=100, samples=10):\n    \n    if dist == None:\n        print('Você esqueceu de carregar uma função que defina a distribuição de X!')\n    else:\n        means = []\n        for j in range(0,samples):\n            x_func_tcl = dist(intervalo[0],intervalo[1],n)\n            mean_x = sum(x_func_tcl)/len(x_func_tcl)\n            \n            means.append(mean_x)\n            mean_of_means = sum(means)/len(means)\n        \n        print('Essa é a lista de médias:')\n        print(means)\n        print('\\nE essa é a média das médias:')\n        print(mean_of_means)\n\n\nnp.random.seed(1)\n\nfunc_tcl(dist=np.random.uniform,intervalo=(-40,40),n=50,samples=10)\n\nEssa é a lista de médias:\n[np.float64(-2.6419520291841945), np.float64(0.382420445207494), np.float64(-2.2971869003899186), np.float64(-0.12856511296217676), np.float64(3.945331018819081), np.float64(4.808427607983528), np.float64(1.1596981846490986), np.float64(0.4583673137720098), np.float64(-2.0177969126899638), np.float64(2.952952578448611)]\n\nE essa é a média das médias:\n0.662169619365357\n\n\nComo acabamos de ver, se quisermos acessar a variável mean_of_means o Python retornará um erro. As variáveis definidas dentro de uma função tem vida curta: elas existem apenas dentro da função!\n\nprint(mean_of_means)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[25], line 1\n----&gt; 1 print(mean_of_means)\n\nNameError: name 'mean_of_means' is not defined\n\n\n\nNo entanto, agora já sabemos o que a palavra-chave return faz dentro de uma função. Vamos utilizá-la!\n\ndef func_tcl(dist=None,intervalo=(0,1),n=100, samples=10):\n    \n    if dist == None:\n        print('Você esqueceu de carregar uma função que defina a distribuição de X!')\n    else:\n        means = []\n        for j in range(0,samples):\n            x_func_tcl = dist(intervalo[0],intervalo[1],n)\n            mean_x = sum(x_func_tcl)/len(x_func_tcl)\n            \n            means.append(mean_x)\n            mean_of_means = sum(means)/len(means)\n        \n        return mean_of_means\n\n\nnp.random.seed(1)\n\nfunc_tcl(dist=np.random.uniform,intervalo=(-40,40),n=50,samples=10)\n\nnp.float64(0.662169619365357)\n\n\nMaravilha, agora a função nos retorna apenas o que é do nosso interesse: a média das médias. Para chegar, finalmente, no mesmo resultado da aula passada basta colocar essa função dentro de um loop e tacar-lhe pau nesse carrinho, Marcos!\n\nexpoentes = [1,2,3,4,5,6,7,8,9,10]\nY = [2**exp for exp in expoentes]\n\nmeans_of_means = []\n\nnp.random.seed(1)\nfor y in Y:\n\n    mean_of_means = func_tcl(dist=np.random.uniform,intervalo=(-40,40),n=100,samples=y)\n    means_of_means.append(mean_of_means)\n\n\nfor m in means_of_means:\n    \n    print(np.round(m,2))\n\n-1.17\n0.92\n0.37\n-0.25\n0.31\n-0.32\n0.23\n-0.15\n-0.06\n0.03\n\n\nVoilá!\nComo exercício para casa, tente fazer alterações nessa função de modo que ela receba não um valor com o número de amostras, mas uma lista de números de amostras. A função deve cuspir como resultado a lista means_of_means e não apenas o valor mean_of_means. Pratique!",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#documentação",
    "href": "funcoes.html#documentação",
    "title": "6  Funções",
    "section": "6.5 Documentação",
    "text": "6.5 Documentação\nUma docstring é uma string no início de uma função, definida pelo usuário, que serve como documentação do que a função faz. A docstring vem logo depois da primeira linha que define a função e é delimitada por aspas triplas, o que permite que a string se estenda por várias linhas, como vocês devem se lembrar.\nVamos criar como exemplo uma função que printa o tipo do objeto que é passado como argumento:\n\ndef imprime_tipo(x):\n    \n    '''\n    Função criada para a matéria EAE1106 - Métodos Computacionais para Economia\n    Objetivo: função simples que imprime o tipo do objeto recebido como argumento.\n    '''\n    \n    print(type(x))\n\nEmbora opcional, a documentação é uma boa prática de programação. A menos que você consiga se lembrar qual foi o cardápio do bandejão na semana passada, sempre documente seu código. Podemos acessar a documentação de determinada função utilizando o atributo __doc__.\n\nprint(imprime_tipo.__doc__)\n\n\nFunção criada para a matéria EAE1106 - Métodos Computacionais para Economia\nObjetivo: função simples que imprime o tipo do objeto recebido como argumento.\n\n\n\nIsso vale também para funções nativas e definidas em outros pacotes do Python. Por exemplo,\n\n# documentação da função nativa len()\nprint(len.__doc__)\n\nReturn the number of items in a container.\n\n\n\nimport time\n\n# documentação da função time() dentro do pacote time\nprint(time.time.__doc__)\n\ntime() -&gt; floating-point number\n\nReturn the current time in seconds since the Epoch.\nFractions of a second may be present if the system clock provides them.\n\n\n\nimport numpy as np\n\n# documentação da função uniform() dentro do pacote NumPy\nprint(np.random.uniform.__doc__)\n\n\n        uniform(low=0.0, high=1.0, size=None)\n\n        Draw samples from a uniform distribution.\n\n        Samples are uniformly distributed over the half-open interval\n        ``[low, high)`` (includes low, but excludes high).  In other words,\n        any value within the given interval is equally likely to be drawn\n        by `uniform`.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.uniform`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.\n\n        Parameters\n        ----------\n        low : float or array_like of floats, optional\n            Lower boundary of the output interval.  All values generated will be\n            greater than or equal to low.  The default value is 0.\n        high : float or array_like of floats\n            Upper boundary of the output interval.  All values generated will be\n            less than or equal to high.  The high limit may be included in the \n            returned array of floats due to floating-point rounding in the \n            equation ``low + (high-low) * random_sample()``.  The default value \n            is 1.0.\n        size : int or tuple of ints, optional\n            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``low`` and ``high`` are both scalars.\n            Otherwise, ``np.broadcast(low, high).size`` samples are drawn.\n\n        Returns\n        -------\n        out : ndarray or scalar\n            Drawn samples from the parameterized uniform distribution.\n\n        See Also\n        --------\n        randint : Discrete uniform distribution, yielding integers.\n        random_integers : Discrete uniform distribution over the closed\n                          interval ``[low, high]``.\n        random_sample : Floats uniformly distributed over ``[0, 1)``.\n        random : Alias for `random_sample`.\n        rand : Convenience function that accepts dimensions as input, e.g.,\n               ``rand(2,2)`` would generate a 2-by-2 array of floats,\n               uniformly distributed over ``[0, 1)``.\n        random.Generator.uniform: which should be used for new code.\n\n        Notes\n        -----\n        The probability density function of the uniform distribution is\n\n        .. math:: p(x) = \\frac{1}{b - a}\n\n        anywhere within the interval ``[a, b)``, and zero elsewhere.\n\n        When ``high`` == ``low``, values of ``low`` will be returned.\n        If ``high`` &lt; ``low``, the results are officially undefined\n        and may eventually raise an error, i.e. do not rely on this\n        function to behave when passed arguments satisfying that\n        inequality condition. The ``high`` limit may be included in the\n        returned array of floats due to floating-point rounding in the\n        equation ``low + (high-low) * random_sample()``. For example:\n\n        &gt;&gt;&gt; x = np.float32(5*0.99999999)\n        &gt;&gt;&gt; x\n        np.float32(5.0)\n\n\n        Examples\n        --------\n        Draw samples from the distribution:\n\n        &gt;&gt;&gt; s = np.random.uniform(-1,0,1000)\n\n        All values are within the given interval:\n\n        &gt;&gt;&gt; np.all(s &gt;= -1)\n        True\n        &gt;&gt;&gt; np.all(s &lt; 0)\n        True\n\n        Display the histogram of the samples, along with the\n        probability density function:\n\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; count, bins, ignored = plt.hist(s, 15, density=True)\n        &gt;&gt;&gt; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n        &gt;&gt;&gt; plt.show()\n\n        \n\n\nNote do exemplo acima que uma docstring pode conter uma descrição detalhada do funcionamento de uma função, inclusive com exemplos de aplicação. Legal, né? Esse tipo de documentação também está disponível para as bibliotecas como um todo. Isso pode nos ajudar, por exemplo, a conhecer o conteúdo de uma determinada biblioteca.\n\nimport numpy as np\n\n# documentação do NumPy\nprint(np.__doc__)\n\n\nNumPy\n=====\n\nProvides\n  1. An array object of arbitrary homogeneous items\n  2. Fast mathematical operations over arrays\n  3. Linear Algebra, Fourier Transforms, Random Number Generation\n\nHow to use the documentation\n----------------------------\nDocumentation is available in two forms: docstrings provided\nwith the code, and a loose standing reference guide, available from\n`the NumPy homepage &lt;https://numpy.org&gt;`_.\n\nWe recommend exploring the docstrings using\n`IPython &lt;https://ipython.org&gt;`_, an advanced Python shell with\nTAB-completion and introspection capabilities.  See below for further\ninstructions.\n\nThe docstring examples assume that `numpy` has been imported as ``np``::\n\n  &gt;&gt;&gt; import numpy as np\n\nCode snippets are indicated by three greater-than signs::\n\n  &gt;&gt;&gt; x = 42\n  &gt;&gt;&gt; x = x + 1\n\nUse the built-in ``help`` function to view a function's docstring::\n\n  &gt;&gt;&gt; help(np.sort)\n  ... # doctest: +SKIP\n\nFor some objects, ``np.info(obj)`` may provide additional help.  This is\nparticularly true if you see the line \"Help on ufunc object:\" at the top\nof the help() page.  Ufuncs are implemented in C, not Python, for speed.\nThe native Python help() does not know how to view their help, but our\nnp.info() function does.\n\nAvailable subpackages\n---------------------\nlib\n    Basic functions used by several sub-packages.\nrandom\n    Core Random Tools\nlinalg\n    Core Linear Algebra Tools\nfft\n    Core FFT routines\npolynomial\n    Polynomial tools\ntesting\n    NumPy testing tools\ndistutils\n    Enhancements to distutils with support for\n    Fortran compilers support and more (for Python &lt;= 3.11)\n\nUtilities\n---------\ntest\n    Run numpy unittests\nshow_config\n    Show numpy build configuration\n__version__\n    NumPy version string\n\nViewing documentation using IPython\n-----------------------------------\n\nStart IPython and import `numpy` usually under the alias ``np``: `import\nnumpy as np`.  Then, directly past or use the ``%cpaste`` magic to paste\nexamples into the shell.  To see which functions are available in `numpy`,\ntype ``np.&lt;TAB&gt;`` (where ``&lt;TAB&gt;`` refers to the TAB key), or use\n``np.*cos*?&lt;ENTER&gt;`` (where ``&lt;ENTER&gt;`` refers to the ENTER key) to narrow\ndown the list.  To view the docstring for a function, use\n``np.cos?&lt;ENTER&gt;`` (to view the docstring) and ``np.cos??&lt;ENTER&gt;`` (to view\nthe source code).\n\nCopies vs. in-place operation\n-----------------------------\nMost of the functions in `numpy` return a copy of the array argument\n(e.g., `np.sort`).  In-place versions of these functions are often\navailable as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.\nExceptions to this rule are documented.\n\n\n\n\nPodemos usar sempre esse atalho caso desejemos conhecer as funcionalidades que uma biblioteca guarda por trás de suas cortinas!",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#funções-anônimas",
    "href": "funcoes.html#funções-anônimas",
    "title": "6  Funções",
    "section": "6.6 Funções anônimas",
    "text": "6.6 Funções anônimas\nEm Python, uma função anônima é uma função definida sem nome. Quem poderia imaginar, não é mesmo?\nEnquanto as funções normais são definidas usando a palavra-chave def em Python, as funções anônimas são definidas usando a palavra-chave lambda. Portanto, funções anônimas também são chamadas de funções lambda. A estrutura usual de uma função lambda é a seguinte:\nlambda &lt;argumentos&gt;: &lt;expressão&gt;\nUsualmente a gente precisa de uma função lambda porque precisamos de uma função rápida por um período de tempo e/ou quando a gente usa técnicas mais poderosas que possuem funções como argumento, como filter e map. Vou fazer um exemplo com cada uma delas.\n\nUsando filter\nA função filter() em Python recebe uma função e uma lista como argumentos. A função é chamada com todos os itens da lista e uma nova lista é retornada contendo itens para os quais a função avalia True. Aqui está um exemplo de uso da função para filtrar apenas números pares de uma lista.\n\nmy_list = [1, 5, 4, 6, 8, 11, 3, 12]\n\nnew_list = list(filter(lambda x: (x%2 == 0) , my_list))\n\nprint(new_list)\n\n[4, 6, 8, 12]\n\n\nUsando map\nA função map() em Python recebe uma função e uma lista. A função é chamada com todos os itens da lista e uma nova lista é retornada contendo os itens retornados por essa função para cada item. Aqui está um exemplo de uso da função map() para dobrar todos os itens em uma lista.\n\nmy_list = [1, 5, 4, 6, 8, 11, 3, 12]\n\nnew_list = list(map(lambda x: x * 2 , my_list))\n\nprint(new_list)\n\n[2, 10, 8, 12, 16, 22, 6, 24]",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "pacotes.html",
    "href": "pacotes.html",
    "title": "Computação numérica, análise de dados e visualização",
    "section": "",
    "text": "Este é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Computação numérica, análise de dados e visualização"
    ]
  },
  {
    "objectID": "numpy.html",
    "href": "numpy.html",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "",
    "text": "7.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental para computação científica em Python. Essa biblioteca é peça fundamental em outras bibliotecas igualmente importantes, como o Pandas e o Matplotlib. É uma biblioteca Python que tem como principal objeto o ndarray, um array multidimensional que guarda bastante semelhança com a ideia de vetores e matrizes, embora seja um objeto específico dentro da linguagem, com suas características e métodos próprios. O pacote contém também uma variedade de rotinas para operações rápidas em arrays, incluindo matemática, lógica, álgebra linear básica, operações estatísticas básicas e muito mais.\nMas o que é de fato um ndarray? É um objeto multidimensional que nos permite armazenar dados de forma sequencial e que podem ser acessados via indexação. Ué, mas isso é muito parecido com uma lista (ou um conjunto de listas). Qual a diferença então?\nSão muitas as qualidades do NumPy que fazem dele a melhor escolha quanto o assunto é lidar com objetos sequenciais, multidimensionais, e com os quais queremos operar tal qual vetores e matrizes. Mas chega de lenga lenga, vamos ao trabalho!",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#o-que-é-o-numpy",
    "href": "numpy.html#o-que-é-o-numpy",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "",
    "text": "NumPy arrays têm um tamanho fixo na criação, ao contrário das listas, que podem crescer. Alterar o tamanho de um ndarray criará um novo array e excluirá o original.\nTodos os elementos em um array devem ser do mesmo tipo de dados, diferentemente de listas, que são objetos mais genéricos. Isso facilita a gestão de memória e torna operações com esse tipo de objeto ordens de magnitude mais rápidas do que se utilizássemos listas.\nA maior velocidade e eficiência de armazenamento fazem do NumPy uma das bibliotecas mais utilizadas em aplicações matemáticas e científicas. Saber apenas as ferramentas nativas do Python, como listas, hoje já não é mais suficiente.",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#elementos-básicos-do-numpy",
    "href": "numpy.html#elementos-básicos-do-numpy",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "7.2 Elementos básicos do NumPy",
    "text": "7.2 Elementos básicos do NumPy\nAntes de tudo, é preciso importar o NumPy, já que se trata de uma biblioteca não nativa do Python.\n\nimport numpy as np\n\n\n7.2.1 Arrays unidimensionais\nComecemos criando um numpy.ndarray do zero, contendo os números 1, 2 e 3. Podemos fazê-lo da seguinte forma:\n\na = np.array([1, 2, 3])\nprint(a)\nprint(type(a))\n\n[1 2 3]\n&lt;class 'numpy.ndarray'&gt;\n\n\nA sintaxe é essa mesma: um par de colchetes dentro dos parênteses. Se tentarmos passar sem os colchetes, o Python retornará um erro.\n\na = np.array(1, 2, 3)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 a = np.array(1, 2, 3)\n\nTypeError: array() takes from 1 to 2 positional arguments but 3 were given\n\n\n\nDa mesma forma que uma sequência de 3 números inteiros, podemos criar um numpy.ndarray que repete 3 vezes o número 0 ou 3 vezes o número 1.\n\na = np.zeros(3)\nb = np.ones(3)\n\nprint(a)\nprint(b)\n\n[0. 0. 0.]\n[1. 1. 1.]\n\n\nNote que em ambos os casos os números aparecem com o ponto da casa decimal, o que é um indicativo de que estão armazenados como valores do tipo float. E se quiséssemos criar esses mesmos arrays, mas especificando que os números são inteiros, i.e., do tipo int?\n\na = np.zeros(3, dtype=int)\nb = np.ones(3, dtype=int)\n\nprint(a)\nprint(b)\n\n[0 0 0]\n[1 1 1]\n\n\nA função numpy.linspace(x,y,z) nos permite criar um array que vai de x até y, com z elementos igualmente espaçados.\n\na = np.linspace(0,8,5, dtype=int)\n\nprint(a)\n\n[0 2 4 6 8]\n\n\nPodemos acessar os elementos de um array qualquer utilizando a mesma ideia de indexação de listas:\n\nprint('Array a =',a)\nprint('\\nPrimeiro elemento de a = ',a[0])\nprint('Segundo elemento de a = ',a[1])\nprint('Último elemento de a = ',a[-1])\nprint('Dois primeiros elementos de a = ',a[0:2])\n\nArray a = [0 2 4 6 8]\n\nPrimeiro elemento de a =  0\nSegundo elemento de a =  2\nÚltimo elemento de a =  8\nDois primeiros elementos de a =  [0 2]\n\n\n\n\n7.2.2 Arrays multidimensionais\nComo falamos anteriormente, um objeto do tipo numpy.ndarray é um array n-dimensional (por isso o nd em ndarray). Até agora trabalhamos apenas com uma dimensão, mas para as nossas aplicações é particularmente interessante o caso em que o número de dimensões é igual a 2, i.e., para o caso em que o array assume a forma de uma matriz.\nPodemos criar esse tipo de array usando a mesma lógica de antes, com pequenas alterações na sintaxe:\n\nA_22 = np.array([[1, 2], [3, 4]], dtype=int)\n\nprint('Matriz A =\\n',A_22)\n\nMatriz A =\n [[1 2]\n [3 4]]\n\n\nO NumPy nos oferece algumas funções interessantes para criarmos matrizes específicas:\n\nprint('Matriz identidade 2x2 =\\n',np.eye(2,dtype=int))\nprint('\\nMatriz diagonal 3x3 =\\n',np.diag([1,2,3]))\n\nMatriz identidade 2x2 =\n [[1 0]\n [0 1]]\n\nMatriz diagonal 3x3 =\n [[1 0 0]\n [0 2 0]\n [0 0 3]]\n\n\nPodemos criar a matriz transposta de uma dada matriz utilizando a função np.transpose() (ou apenas o método .T):\n\nprint('Matriz A =\\n',A_22)\nprint('\\nTransposta da matriz A =\\n',np.transpose(A_22))\nprint('\\nTransposta da matriz A =\\n',A_22.T)\n\nMatriz A =\n [[1 2]\n [3 4]]\n\nTransposta da matriz A =\n [[1 3]\n [2 4]]\n\nTransposta da matriz A =\n [[1 3]\n [2 4]]\n\n\nAssim como em arrays unidimensionais, podemos acessar os elementos de uma matriz utilizando indexação, mas agora em 2 dimensões:\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\n\nprint('Matriz A =\\n',A)\nprint('\\nElemento 11 de A = ',A[0,0])\nprint('Elemento 23 de A = ',A[1,2])\nprint('Primeira linha de A = ',A[0,:])\nprint('Segunda coluna de A = ',A[:,1])\nprint('\\nSubmatriz de A delimitada pelos elementos 22 e 33 =\\n',A[1:,1:])\n\nMatriz A =\n [[1 2 3]\n [4 5 6]\n [7 8 9]]\n\nElemento 11 de A =  1\nElemento 23 de A =  6\nPrimeira linha de A =  [1 2 3]\nSegunda coluna de A =  [2 5 8]\n\nSubmatriz de A delimitada pelos elementos 22 e 33 =\n [[5 6]\n [8 9]]\n\n\n\n\n7.2.3 Propriedades de arrays\nO NumPy fornece alguns métodos úteis que, apesar de não receberem nenhum argumento, nos permitem acessar algumas das características dos arrays que criamos.\n\nndim retorna o número de dimensões do array;\nshape retorna o tamanho do array em cada uma de suas dimensões;\ndtype retorna o tipo de dado contido no array;\nsize retorna o número total de elementos contidos no array.\n\n\nX1 = np.array([[1,2,3], [4,5,6], [7,8,9]]) \nX2 = X1.flatten() # O método flatten reduz um array de n-dimensões em um array de uma única dimensão\n\nprint('Array X1 =\\n',X1)\nprint('\\nDimensões de X1 = ', X1.ndim)\nprint('Shape de X1 = ', X1.shape)\nprint('Tipo de dado em X1 = ', X1.dtype)\nprint('Número de elementos em X1 = ', X1.size)\n\nprint('\\n\\nArray X2 =\\n',X2)\nprint('\\nDimensões de X2 = ', X2.ndim)\nprint('Shape de X2 = ', X2.shape)\nprint('Tipo de dado em X2 = ', X2.dtype)\nprint('Número de elementos em X2 = ', X2.size)\n\nArray X1 =\n [[1 2 3]\n [4 5 6]\n [7 8 9]]\n\nDimensões de X1 =  2\nShape de X1 =  (3, 3)\nTipo de dado em X1 =  int64\nNúmero de elementos em X1 =  9\n\n\nArray X2 =\n [1 2 3 4 5 6 7 8 9]\n\nDimensões de X2 =  1\nShape de X2 =  (9,)\nTipo de dado em X2 =  int64\nNúmero de elementos em X2 =  9\n\n\nUm método interessante de arrays é o reshape(x,y) que reorganiza um array existente de acordo com os argumentos x e y:\n\nX = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]) \n\nprint('Array X1 4x4 =\\n',X)\nprint('\\n X1 reorganizado em 2x8 =\\n',X.reshape(2,8))\nprint('\\n X1 reorganizado em 8x2 =\\n',X.reshape(8,2))\n\nArray X1 4x4 =\n [[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]\n [13 14 15 16]]\n\n X1 reorganizado em 2x8 =\n [[ 1  2  3  4  5  6  7  8]\n [ 9 10 11 12 13 14 15 16]]\n\n X1 reorganizado em 8x2 =\n [[ 1  2]\n [ 3  4]\n [ 5  6]\n [ 7  8]\n [ 9 10]\n [11 12]\n [13 14]\n [15 16]]",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#operações-básicas-com-arrays",
    "href": "numpy.html#operações-básicas-com-arrays",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "7.3 Operações básicas com arrays",
    "text": "7.3 Operações básicas com arrays\n\n7.3.1 Operações aritméticas simples\nDois tipos de operações que serão úteis para arrays de qualquer dimensão são:\n\nOperações entre um array e um único número.\nOperações entre dois arrays da mesma forma.\n\nQuando realizamos operações em um array usando um único número, simplesmente aplicamos essa operação a cada elemento do array. Isso vale tanto para arrays unidimensionais (vetores) quanto multidimensionais (por ex., matrizes).\n\nx = np.array([1,2,3], dtype=int)\nprint(\"x =\\n\", x)\nprint(\"\\n2 + x =\\n\", 2 + x)\nprint(\"\\n2 - x =\\n\", 2 - x)\nprint(\"\\n2 * x =\\n\", 2 * x)\nprint(\"\\nx / 2 =\\n\", x / 2)\n\nx =\n [1 2 3]\n\n2 + x =\n [3 4 5]\n\n2 - x =\n [ 1  0 -1]\n\n2 * x =\n [2 4 6]\n\nx / 2 =\n [0.5 1.  1.5]\n\n\n\nX = np.ones((2, 2), dtype=int)\n\nprint(\"X =\\n\", X)\nprint(\"\\n2 + X =\\n\", 2 + X)\nprint(\"\\n2 - X =\\n\", 2 - X)\nprint(\"\\n2 * X =\\n\", 2 * X)\nprint(\"\\nX / 2 =\\n\", X / 2)\n\nX =\n [[1 1]\n [1 1]]\n\n2 + X =\n [[3 3]\n [3 3]]\n\n2 - X =\n [[1 1]\n [1 1]]\n\n2 * X =\n [[2 2]\n [2 2]]\n\nX / 2 =\n [[0.5 0.5]\n [0.5 0.5]]\n\n\nPara operações entre dois arrays de mesmo tamanho, basta aplicar a operação elemento a elemento (elementwise, em inglês) entre os arrays.\n\nx = np.array([2, 4, 6], dtype=int)\ny = np.array([2, 2, 1], dtype=int)\n\nprint(\"x =\\n\", x)\nprint(\"\\ny =\\n\", y)\nprint(\"\\nx + y =\\n\", x + y)\nprint(\"\\nx - y =\\n\", x - y)\n\nx =\n [2 4 6]\n\ny =\n [2 2 1]\n\nx + y =\n [4 6 7]\n\nx - y =\n [0 2 5]\n\n\n\nX = np.array([[2, 4], [6, 8]], dtype=int)\nY = np.array([[2, 2], [2, 2]], dtype=int)\n\nprint(\"X =\\n\", X)\nprint(\"\\nY =\\n\", Y)\nprint(\"\\nX + Y =\\n\", X + Y)\nprint(\"\\nX - Y =\\n\", X - Y)\n\nX =\n [[2 4]\n [6 8]]\n\nY =\n [[2 2]\n [2 2]]\n\nX + Y =\n [[ 4  6]\n [ 8 10]]\n\nX - Y =\n [[0 2]\n [4 6]]\n\n\nAs operações de multiplicação e divisão entre arrays são um pouco diferentes. São duas as possibilidades:\n\nMultiplicação e divisão elemento a elemento.\nMultiplicação entre arrays usando a lógica de matriz e “divisão” usando a lógica de matriz inversa.\n\nPara realizar as operações elementwise basta utilizar os sinais usuais de * e /, independentemente do número de dimesões do array.\n\nprint('Vetores x e y:')\nprint('x =',x)\nprint('y =',y)\nprint(\"\\n x * y =\\n\", x * y)\nprint(\"\\n x / y =\\n\", x / y)\n\nprint('\\nMatrizes X e Y:')\nprint('X =\\n',X)\nprint('Y =\\n',Y)\nprint(\"\\n X * Y =\\n\", X * Y)\nprint(\"\\n X / Y =\\n\", X / Y)\n\nVetores x e y:\nx = [2 4 6]\ny = [2 2 1]\n\n x * y =\n [4 8 6]\n\n x / y =\n [1. 2. 6.]\n\nMatrizes X e Y:\nX =\n [[2 4]\n [6 8]]\nY =\n [[2 2]\n [2 2]]\n\n X * Y =\n [[ 4  8]\n [12 16]]\n\n X / Y =\n [[1. 2.]\n [3. 4.]]\n\n\nA multiplicação de matriz com matriz, do jeito que a gente conhece do Ensino Médio é feita usando o símbolo @ (ou através da função np.dot()):\n\nX= np.array([[1, 2], [3, 4]], dtype=int)\nY= np.array([[10, 20], [30, 40]], dtype=int)\n\nprint('X =\\n',X)\nprint('Y =\\n',Y)\nprint('\\nX * Y =\\n', X @ Y)\nprint('\\nX * Y =\\n', np.dot(X,Y))\n\nX =\n [[1 2]\n [3 4]]\nY =\n [[10 20]\n [30 40]]\n\nX * Y =\n [[ 70 100]\n [150 220]]\n\nX * Y =\n [[ 70 100]\n [150 220]]\n\n\nPara calcular a inversa de uma matriz utilizando o NumPy é preciso um pouco mais de estrutura e de conhecimento acerca do subpacote linalg que nos traz funções para realizar operações de álgebra linear. Falaremos disso já já!\n\n\n7.3.2 Funções universais\nAs funções universais no Numpy são funções matemáticas simples. É apenas um termo que demos às funções matemáticas na biblioteca Numpy, que cobrem uma ampla variedade de operações. Essas funções incluem funções trigonométricas padrão, funções para operações aritméticas, manipulação de números complexos, funções estatísticas, etc. Essas funções possuem como características principais:\n\nElas executam operações de array elemento por elemento.\nElas suportam vários recursos, como conversão de tipos.\nAs funções universais são objetos que pertencem à classe numpy.ufunc.\nAs funções do Python também podem ser criadas como uma função universal usando a função da biblioteca frompyfunc.\nAlgumas funções universais são chamadas automaticamente quando o operador aritmético correspondente é usado em arrays. Por exemplo, quando a adição de dois arrays é executada em elementos usando o operador ‘+’, então np.add() é chamado internamente.\n\nDentre as principais funções universais matemáticas estão:\n\nsin, cos, tan: calcular seno, cosseno e tangente de ângulos.\nhypot: calcule a hipotenusa do triângulo retângulo dado.\narcsinh, arcosh, arctanh: calcular seno hiperbólico inverso, cosseno e tangente.\ndeg2rad: converter grau em radianos.\nrad2deg: converter radianos em graus.\n\nDentre as principais funções universais estatísticas estão:\n\namin, amax: retorna o mínimo ou máximo de um array ou ao longo de um eixo.\nptp: retorna o intervalo de valores (máximo-mínimo) de um array ou ao longo de um eixo.\nsum: retorna a soma de valores de um array ao longo de um eixo.\npercentile(a, p, eixo): calcular o p-ésimo percentil da matriz ou ao longo do eixo especificado.\nmedian: calcular a mediana dos dados ao longo do eixo especificado.\nmean: calcular a média dos dados ao longo do eixo especificado.\nvar: calcular a variância de dados ao longo do eixo especificado.\nlog: calcular o log dos dados ao longo do eixo especificado.\n\nAlguns exemplos:\n\nangulos_notaveis_deg = np.array([30,45,60])\nangulos_notaveis_rad = np.deg2rad(angulos_notaveis_deg)\n\nseno_notaveis = [np.round(elem,2) for elem in np.sin(angulos_notaveis_rad)]\ncosseno_notaveis = [np.round(elem,2) for elem in np.cos(angulos_notaveis_rad)]\ntangente_notaveis = [np.round(elem,2) for elem in np.tan(angulos_notaveis_rad)]\n\nprint('Seno, cosseno e tangente de 30 graus: ',seno_notaveis[0],', ',cosseno_notaveis[0],' e ',tangente_notaveis[0])\nprint('Seno, cosseno e tangente de 45 graus: ',seno_notaveis[1],', ',cosseno_notaveis[1],' e ',tangente_notaveis[1])\nprint('Seno, cosseno e tangente de 60 graus: ',seno_notaveis[2],', ',cosseno_notaveis[2],' e ',tangente_notaveis[2])\n\nSeno, cosseno e tangente de 30 graus:  0.5 ,  0.87  e  0.58\nSeno, cosseno e tangente de 45 graus:  0.71 ,  0.71  e  1.0\nSeno, cosseno e tangente de 60 graus:  0.87 ,  0.5  e  1.73\n\n\n\nx = np.array([1,2,3,4,5])\n\nprint('Array x = ',x)\nprint('\\nMínimo de x = ',np.amin(x))\nprint('Máximo de x = ',np.amax(x))\nprint('Intervalo de x = ',np.ptp(x))\nprint('Soma de x = ',np.sum(x))\nprint('Média de x = ',np.mean(x))\nprint('Log de x = ',[np.round(elem,2) for elem in np.log(x)])\n\nArray x =  [1 2 3 4 5]\n\nMínimo de x =  1\nMáximo de x =  5\nIntervalo de x =  4\nSoma de x =  15\nMédia de x =  3.0\nLog de x =  [np.float64(0.0), np.float64(0.69), np.float64(1.1), np.float64(1.39), np.float64(1.61)]\n\n\n\n\n7.3.3 Arrays e listas\nAgora que já vimos um pouco de operações básicas, podemos entender um pouco melhor a diferença de desempenho entre arrays e listas. Considere um array de dez milhões de números inteiros e uma lista equivalente:\n\nmy_array = np.arange(10000000)\nmy_list = list(range(10000000))\n\nAgora vamos multiplicar, elemento a elemento, todos os números por 2 e salvar o resultado correspondente. Utilizaremos a função time do pacote timepara fazer a medição do tempo utilizado pelos dois métodos.\n\nimport time \n\n# arrays\nstart_array = time.time()\nmy_array2 = my_array * 2\nend_array   = time.time()\n\n\n# listas\nstart_lista = time.time()\nmy_list2 = [x * 2 for x in my_list] \nend_lista   = time.time()\n\nratio = (end_lista - start_lista) / (end_array - start_array)\n\nQual abordagem será que levou menos tempo?\n\nprint('Tempo necessário para a realização dos cálculos utilizando arrays: {:.4f} segundos'.format(end_array - start_array))\nprint('Tempo necessário para a realização dos cálculos utilizando listas: {:.4f} segundos'.format(end_lista - start_lista))\nprint('\\nA abordagem de listas demorou {:.0f}x mais tempo! Esqueça listas e use arrays ;)'.format(ratio - 1))\n\nTempo necessário para a realização dos cálculos utilizando arrays: 0.0124 segundos\nTempo necessário para a realização dos cálculos utilizando listas: 0.2755 segundos\n\nA abordagem de listas demorou 21x mais tempo! Esqueça listas e use arrays ;)",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#aplicação-solução-de-sistema-de-equações-lineares",
    "href": "numpy.html#aplicação-solução-de-sistema-de-equações-lineares",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "7.4 Aplicação: solução de sistema de equações lineares",
    "text": "7.4 Aplicação: solução de sistema de equações lineares\nChega de exemplos vazios, vamos usar o NumPy para resolver um problema concreto e que nos é muito familiar: a solução de sistemas de equações lineares. Considere o sistema linear de equações dado por\n\\[ A\\cdot \\vec{x} = \\vec{b} \\]\ntal que \\(A\\) é a matriz de coeficientes, \\(\\vec{x}\\) é o vetor de incógnitas e \\(\\vec{b}\\) o vetor de constantes.\n\n7.4.1 Algoritmo de eliminação de Gauss-Jordan\nSegundo Hubbard e Hubbard (2015), uma matriz de coeficientes \\(A\\) é representada em sua forma escalonada reduzida por linhas (reduced row echelon form, em inglês) se\n\nEm toda e qualquer linha, a primeira entrada diferente de zero é igual a 1 (1 pivotal).\nO 1 pivotal de uma linha mais abaixo está sempre à direita de um outro 1 pivotal de alguma linha acima.\nEm toda e qualquer coluna que contém um 1 pivotal, todas as outras entradas são iguais a zero.\nToda linha contendo apenas zeros está no fim da matriz.\n\nÀ partir dessa definição, é possível mostrar que para qualquer matriz \\(A\\), existe uma matriz \\(\\tilde{A}\\) na forma escalonada reduzida por linhas que pode ser obtida à partir de operações elementares nas linhas de A. Além disso, é possível mostrar também que \\(\\tilde{A}\\) é única. Ao algoritmo utilizado para encontrar \\(\\tilde{A}\\) é dado o nome de Algoritmo de Eliminação de Gauss-Jordan.\n\n\nALGORITMO DE ELIMINAÇÃO DE GAUSS-JORDAN\nPara levar uma matriz \\(A\\) a sua forma escalonada reduzida por linhas \\(\\tilde{A}\\) devemos seguir os seguintes passos:\n\n\nEncontre a primeira coluna que não é composta apenas de zeros, chame isso de primeira coluna pivotal e chame sua primeira entrada diferente de zero de pivô. Se o pivô não for na primeira linha, mova a linha que a contém para o topo da matriz.\n\n\n\nDivida a primeira linha inteira pelo pivô, de modo que a primeira entrada da primeira coluna pivotal seja igual a 1.\n\n\n\nAdicione múltiplos apropriados da primeira linha às outras linhas para garantir que todas as outras entradas da primeira coluna pivotal sejam iguais a 0. O 1 na primeira coluna é agora um pivô 1.\n\n\n\nEscolha a próxima coluna que contém pelo menos uma entrada diferente de zero abaixo da primeira linha e coloque a linha que contém o novo pivô na posição da segunda linha. Faça do pivô um pivô 1: divida a linha inteira pelo pivô e adicione múltiplos apropriados desta linha às outras linhas abaixo, para tornar todas as outras entradas desta coluna iguais a 0.\n\n\n\nRepita o processo até que a matriz esteja em sua forma escalonada reduzida por linhas.\n\n\n\nAssuma o caso em que a matriz de coeficiente \\(A\\) e o vetor de constantes \\(b\\) são tais que a matriz ampliada é dada por:\n\\[\\left[\\begin{array}{ccc|c} 2 & 2 & 1 & 1 \\\\ 1 & 3 & 1 & 2 \\\\ 1 & 2 & 2 & -1 \\end{array}\\right] \\]\n\nPasso 1: Defina a matriz M\n\n\nM = np.array([(2, 2, 1, 1),\n              (1, 3, 1, 2),\n              (1, 2, 2, -1)],dtype=float)\nprint('Matriz ampliada =\\n',M)\n\nMatriz ampliada =\n [[ 2.  2.  1.  1.]\n [ 1.  3.  1.  2.]\n [ 1.  2.  2. -1.]]\n\n\n\nPasso 2: Divida a linha 1 pelo primeiro elemento da primeira linha\n\n\nM[0,:] = M[0,:] / M[0,0]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 1.   3.   1.   2. ]\n [ 1.   2.   2.  -1. ]]\n\n\n\nPasso 3: Subtraia a linha 1 da linha 2 e da linha 3\n\n\nM[1,:] = M[1,:] - M[0,:]\nM[2,:] = M[2,:] - M[0,:]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 0.   2.   0.5  1.5]\n [ 0.   1.   1.5 -1.5]]\n\n\n\nPasso 4: Divida a linha 2 pelo segundo elemento da segunda linha\n\n\nM[1,:] = M[1,:] / M[1,1]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    1.    1.5  -1.5 ]]\n\n\n\nPasso 5: Subtraia a linha 2 da linha 3\n\n\nM[2,:] = M[2,:] - M[1,:]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    0.    1.25 -2.25]]\n\n\n\nPasso 6: Divida a linha 3 pelo terceiro elemento da terceira linha\n\n\nM[2,:] = M[2,:] / M[2,2]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    0.    1.   -1.8 ]]\n\n\n\nPasso 7: Multiplique a linha 3 pelo terceiro elemento da segunda linha e subtraia da linha 2\n\n\nM[1,:] = M[1,:] - M[1,2] * M[2,:]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\n\nPasso 8: Multiplique a linha 3 pelo terceiro elemento da primeira linha e subtraia da linha 1\n\n\nM[0,:] = M[0,:] - M[0,2] * M[2,:]\n\nprint(M)\n\n[[ 1.   1.   0.   1.4]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\n\nPasso 9: Subtraia a linha 2 da linha 1\n\n\nM[0,:] = M[0,:] - M[1,:]\n\nprint(M)\n\n[[ 1.   0.   0.   0.2]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\nTemos a nossa matriz em sua forma escalonada reduzida por linhas! A solução do sistema é tal que:\n\nprint('A solução de x1 é: {:.2f}'.format(M[0,3]))\nprint('A solução de x2 é: {:.2f}'.format(M[1,3]))\nprint('A solução de x3 é: {:.2f}'.format(M[2,3]))\n\nA solução de x1 é: 0.20\nA solução de x2 é: 1.20\nA solução de x3 é: -1.80\n\n\nUma forma mais simples de chegar na forma escalonada reduzida por linhas é através do pacote SymPy e das funções Matrix e rref:\n\nimport sympy\n\nM_sympy = sympy.Matrix([(2, 2, 1, 1),\n                        (1, 3, 1, 2),\n                        (1, 2, 2, -1)])\n\nM_sympy.rref()[0]\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & \\frac{1}{5}\\\\0 & 1 & 0 & \\frac{6}{5}\\\\0 & 0 & 1 & - \\frac{9}{5}\\end{matrix}\\right]\\)\n\n\n\n\n7.4.2 Solução de sistemas exatamente identificados\nUma outra forma de resolver sistemas de equações exatamente identificados, quando o número de incógnitas é igual ao número de equações (i.e., matriz \\(A\\) é quadrada) é através da matriz inversa de \\(A\\). Para o caso em que \\(A^{-1}\\) existe, o sistema é tal que\n\\[ \\vec{x} = A^{-1} \\cdot \\vec{b} \\]\nPara que seja possível fazer dessa forma, \\(A\\) deve ser uma matriz quadrada e seu determinante ser diferente de \\(0\\). Mais uma vez assuma o caso em que \\(A\\) e \\(\\vec{b}\\) são dados por:\n\\[A = \\begin{bmatrix} 2 & 2 & 1 \\\\ 1 & 3 & 1 \\\\ 1 & 2 & 2 \\end{bmatrix} \\quad \\quad \\vec{b} = \\begin{bmatrix} 1 \\\\ 2 \\\\ -1 \\end{bmatrix} \\]\nO primeiro passo é conferir se a matrix \\(A\\) é quadrada. Podemos fazer isso usando a função numpy.shape()\n\nb = np.array([1, 2, -1])\nA = np.array([(2, 2, 1), (1, 3, 1), (1, 2, 2)])\n\nnp.shape(A)[0] == np.shape(A)[1]\n\nTrue\n\n\nO próximo passo é ver se o determinante da matriz é igual a 0 e para isso usamos um função do subpacote de álgebra linera do numpy, numpy.linalg.det():\n\nprint('A =')\nprint(A)\n\nprint('\\nDeterminante = ',np.round(np.linalg.det(A)))\n\nA =\n[[2 2 1]\n [1 3 1]\n [1 2 2]]\n\nDeterminante =  5.0\n\n\nComo ambas as condições são satisfeitas, por fim basta calcular a inversa da matriz \\(A\\) com numpy.linalg.inv() e multiplicar por \\(\\vec{b}\\) para chegar nos valores de x, y e z que solucionam o sistema de equações.\n\nprint('A =')\nprint(A)\n\nprint(\"\\nInversa de A = \")\nprint(np.linalg.inv(A))\n\nA =\n[[2 2 1]\n [1 3 1]\n [1 2 2]]\n\nInversa de A = \n[[ 0.8 -0.4 -0.2]\n [-0.2  0.6 -0.2]\n [-0.2 -0.4  0.8]]\n\n\n\nsolution = np.linalg.inv(A) @ b\nsolution\n\narray([ 0.2,  1.2, -1.8])\n\n\n\nprint('A solução de x1 é: {:.2f}'.format(solution[0]))\nprint('A solução de x2 é: {:.2f}'.format(solution[1]))\nprint('A solução de x3 é: {:.2f}'.format(solution[2]))\n\nA solução de x1 é: 0.20\nA solução de x2 é: 1.20\nA solução de x3 é: -1.80\n\n\nUma última alternativa para resolver o sistema \\(A\\cdot \\vec{x} = \\vec{b}\\), é utilizar a função solve do subpacote de álgebra linear do NumPy. Essa função faz o processo de resolução do sistema de forma direta e nos cospe o vetor de resultado.\n\nnp.linalg.solve(A,b)\n\narray([ 0.2,  1.2, -1.8])",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "pandas.html",
    "href": "pandas.html",
    "title": "8  Gestão e análise de dados",
    "section": "",
    "text": "8.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Gestão e análise de dados</span>"
    ]
  },
  {
    "objectID": "visualizacao.html",
    "href": "visualizacao.html",
    "title": "9  Visualização",
    "section": "",
    "text": "9.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Visualização</span>"
    ]
  },
  {
    "objectID": "projeto_empirico.html",
    "href": "projeto_empirico.html",
    "title": "10  Análise empírica integrada",
    "section": "",
    "text": "10.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Análise empírica integrada</span>"
    ]
  },
  {
    "objectID": "complemento.html",
    "href": "complemento.html",
    "title": "Temas complementares",
    "section": "",
    "text": "Este é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Temas complementares"
    ]
  },
  {
    "objectID": "oop.html",
    "href": "oop.html",
    "title": "11  Introdução à programação orientada a objetos (OOP)",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Temas complementares",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introdução à programação orientada a objetos (OOP)</span>"
    ]
  },
  {
    "objectID": "intror.html",
    "href": "intror.html",
    "title": "12  Introdução ao R",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Temas complementares",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  }
]