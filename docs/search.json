[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EAE1106 - Métodos Computacionais para Economia",
    "section": "",
    "text": "Bem-vindo\nEste é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "index.html#agradecimentos-e-reprodução",
    "href": "index.html#agradecimentos-e-reprodução",
    "title": "EAE1106 - Métodos Computacionais para Economia",
    "section": "Agradecimentos e reprodução",
    "text": "Agradecimentos e reprodução\nEsse material deve muito a X, Y e Z\nEsse material foi construído bla bla bla. Qualquer erro é de responsabilidade exclusiva do autor. Todo e qualquer feedback é muito bem-vindo.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introdução",
    "section": "",
    "text": "Este é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Introdução"
    ]
  },
  {
    "objectID": "alfabetizacao.html",
    "href": "alfabetizacao.html",
    "title": "Alfabetização computacional e lógica básica",
    "section": "",
    "text": "Este é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Alfabetização computacional e lógica básica"
    ]
  },
  {
    "objectID": "fundamentos.html",
    "href": "fundamentos.html",
    "title": "1  Fundamentos de computação",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentos de computação</span>"
    ]
  },
  {
    "objectID": "primeiros_passos.html",
    "href": "primeiros_passos.html",
    "title": "2  Primeiros passos no Python",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros passos no Python</span>"
    ]
  },
  {
    "objectID": "inteligencia_artificial.html",
    "href": "inteligencia_artificial.html",
    "title": "3  Programação e IA",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Programação e IA</span>"
    ]
  },
  {
    "objectID": "objetos.html",
    "href": "objetos.html",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "",
    "text": "4.1 Strings\nIn summary, this book has no content whatsoever.\nStrings não são como números inteiros ou de ponto flutuate. No Python, uma string nada mais é do que uma sequência ordenada de caracteres unicode. Eles são delimitados sempre por aspas (simplas ou duplas). Relembrando nosso primeiro “programa” da aula passada podemos atribuir a uma variável a string Hello, World usando aspas.\nUsando aspas duplas o resultado seria o mesmo\nNote que podemos também usar uma sequência de três aspas duplas e escrever strings que percorrem várias linhas.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#strings",
    "href": "objetos.html#strings",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "",
    "text": "str1 = 'Hello, World'\n\nprint(str1)\nprint(type(str1))\n\nstr2 = \"Hello, World\"\n\nprint(str2)\nprint(type(str2))\n\nstr3 = \"\"\"Das Utopias\n\nSe as coisas são inatingíveis...ora!\nNão é motivo para não querê-las...\nQue tristes os caminhos, se não fora\nA presença distante das estrelas!\n           \nMario Quintana \n\"\"\"\n\nprint(str3)\nprint(type(str3))\n\n4.1.1 Operações básicas\nPor ser uma sequência de caracteres e não um número, operações aritméticas (em geral) não são permitidas, mas outras operações, como slicing, o são. É possível acessar um caracter específico da sequência utilizando a posição desse caractere, utilizando o que chamamos de índice. No caso do string ‘Hello, World’, para acessar a segunda letra podemos utilizar colchetes após o string e dentro dele o índice referente à posição do ‘e’ no string:\nprint(str1)\nstr1[2]\nUé, mas porque que obtivemos como resposta o caractere ‘l’, que é o 3º na sequência, e não o ‘e’, que é o 2º elemento? Aqui vai uma particularidade da sintaxe do Python: em se tratando de índices, o Python sempre começa a contagem em 0!. Dessa forma, para acessar o primeiro caractere de ‘Hello, World’ devemos pedir str1[0], para acessar o segundo é preciso pedir str1[1] e assim por diante.\nstr1[1]\nPodemos acessar contando de trás para frente e usando um índice negativo\nstr1[-11]\nÉ possível que o índice seja uma expressão, mas deve sempre ser um valor inteiro.\nn=0\nstr1[n+1]\nstr1[1.5]\nPara acessar uma fatia (slice) do string podemos utilizar um intervalo de índices (inclusive o índice inicial e exclusive o índice final). Por exemplo,\nstr1[0:5]\nAlém de ser possível calcular o número de caracteres em uma sequência string utilizando a função integrada len(), podemos “concatenar” ou “somar” strings utilizando apenas o sinal de +\nlen(str1)\nstr1 + ' --- ' + str2\nNote, porém, que strings são imutáveis, de modo que caso queira substituir um dos caracteres dentro de um string é preciso utilizar uma função específica para isso ou criar um novo string derivado do 1º. Apenas tentar substituir um dos caracteres de um string já definido não é permitido.\n# Tentemos substituir o 'e' do str1 por 'a'\nstr1[1] = 'a'\n\n\n4.1.2 Métodos de strings\nAs strings oferecem métodos que executam várias operações úteis. Um método é em essência uma sequência de instruções encapsuladas dentro de um único comando que recebe argumentos e devolve um valor. Embora a sintaxe seja diferente, a ideia é a mesma quando falamos de funções, objeto do nosso estudo daqui algumas aulas.\nNo caso dos métodos, temos que passar o nome da string que foi definida anteriormente seguida de ‘.’ e depois do comando relacionado ao método específico. Dentre os principais métodos aplicáveis a strings e suas funcionalidades podemos citar: \n\nstr_example.upper(): devolve a string ‘str_example’ toda em letras maiúsculas. \nstr_example.lower(): devolve a string ‘str_example’ toda em letras minúsculas. \nstr_example.strip(): devolve a string ‘str_example’ retirando possíveis espaços em branco no início e no fim da string. \nstr_example.startswith(‘xyz’): testa se a string ‘str_example’ começa com a string ‘xyz’. \nstr_example.endswith(‘xyz’): testa se a string ‘str_example’ termina com a string ‘xyz’. \nstr_example.find(‘xyz’): procura a string ‘xyz’ dentro de ‘str_example’ e retorna o primeiro índice onde ‘xyz’ começa ou retorna -1 se nada for encontrado. \nstr_example.replace(‘old’,‘new’): retorna uma string nova onde todas as ocorrências de ‘old’ encontradas em ‘str_example’ serão substituídas por ‘new’. \n\nAlém desses principais, existem outros vários métodos para strings. Esse link é um bom ponto de partida para quem quiser conhecer outros exemplos.\nstr1 = ' Hello, World '\n\nprint(str1.upper())\nprint(str1.lower())\nprint(str1.strip())\nprint(str1.startswith(' '))\nprint(str1.endswith('d'))\nprint(str1.find(','))\nprint(str1.replace('Hello','World'))\n\n\n4.1.3 Formatação e a instrução print\nUm método sobre o qual não falamos, mas que é bastante interessante quando queremos, por exemplo, printar bonitinho o resultado de determinada operação é s.format(). Com esse método podemos converter uma variável numérica para uma formato específico e printá-la dentro de um string maior. Imagine, por exemplo, que estejamos interessados em printar o valor de \\(\\pi\\) arredondado para 2 casas decimais apenas dentro de um string que diz isso. Podemos implementar isso da seguinte forma\npi = 3.1415926535\nprint('O valor de pi arredondado para 2 casas decimais é {:.2f}. Interessante, não?'.format(pi))\nOs colchetes dentro do string mostram onde que o número deve aparecer. Mais do que isso, definimos dentro do colchete o formato do número. Após os ‘:’, o ‘.2’ significa que queremos 2 casas decimais enquanto ‘f’ significa que queremos um formato de ponto fixo. Não vou entrar nos detalhes de todas as formatações possíveis, mas podemos ver um pouco mais disso aqui.\nPodemos também usar mais de um número dentro do mesmo método format. Por exemplo,\nprint('O valor de pi arredondado para 2 casas decimais é {:.2f}. Com 4 casas decimais, no entanto, o número é um pouco maior e igual a {:.4f}. Interessante, não?'.format(pi,pi))\n\n\n4.1.4 Introdução a expressões regulares\nPor vezes queremos encontrar um padrão específico de texto (e.g., placas de carro, e-mails ou números de telefone) dentro de um texto maior, para realizar algum tipo de coleta, limpeza ou mesmo substituição que um simples str.replace() não dá conta. Para realizar tal ação podemos utilizar as famosas Expressões Regulares, também conhecidas como Regular Expressions no inglês, ou simplesmente Regex.\nAs expressões regulares são em essência uma potente linguagem para especificar padrões de texto. De forma mais detalhada, é uma composição dos chamados metacaracteres, caracteres com funções especiais, que, agrupados entre si e em conjunto com caracteres literais, formam uma sequência, uma expressão. Essa expressão é interpretada como uma regra que indicará sucesso se uma entrada de dados qualquer casar com essa regra, ou seja, obedecer exatamente a todas as suas condições.\nImagine que você tenha o string abaixo, que mostra o texto de um trecho de uma notícia da CNN sobre o resultado da Pesquisa Datafolha para presidente divulgada em 18/08/2022 (link para a matéria completa aqui).\npesquisa = \"\"\"\nPesquisa Datafolha divulgada nesta quinta-feira (18) mostra o ex-presidente Luiz Inácio Lula da Silva (PT) à frente, \ncom 47% das intenções de voto na corrida pelo Palácio do Planalto. O presidente Jair Bolsonaro (PL) tem 32%. \nO primeiro turno das eleições acontece em 2 de outubro.\n\nNa sequência, aparecem Ciro Gomes (PDT), com 7%; Simone Tebet (MDB), com 2%, e Vera Lúcia (PSTU), com 1%.\n\"\"\"\n\nprint(pesquisa)\nE se quiséssemos, por exemplo, substituir todas as porcentagens de intenção de voto por ‘ZZZ’? Note que as porcentagens são diferentes e não há uma repetição dos números que nos permita usar o str.replace() de uma vez só. No entanto, todas as porcentagens são representadas por 1 ou 2 números inteiros seguidos do símbolo \\(\\%\\). Nesse caso, o mais indicado é utilizar as expressões regulares.\nOs módulos e funções nativas do Python não nos trazem muito material para trabalhar com expressões regulares. Para operar com elas utilizaremos uma biblioteca de comandos chamada re. Para trazer para dentro do Python as funcionalidades dessa biblioteca precisamos utilizar a função import seguida do nome da biblioteca.\nimport re\nFalaremos mais sobre importação de bibliotecas de comandos e funções mais a frente, mas por hora tenha na cabeça que para utilizar um conjunto de instruções disponível em alguma biblioteca importada é preciso utilizar o nome da biblioteca seguido de ponto e do nome da função dessa biblioteca que você quer utilizar. No caso, para realizar a substituição das porcentagens no string pesquisa utilizaremos a função sub() de dentro da biblioteca re. Mas o que devemos colocar como input dessa função?\nO mundo das expressões regulares é um mundo gigante e à parte, com conteúdo suficiente para preencher um outro curso. De forma geral, a combinação entre metacaracteres e caracteres literais é o que dá o padrão do texto pelo qual procuramos. Alguns dos metacaracteres-padrão são . ? * + ^ | [ ] { } ( ) \\, cada um realizando uma função específica. Para o nosso caso utilizaremos basicamente a expressão regular dada por\n[0-9]{1,2}%\nMas o que essa coisa bizarra diz de fato? A função buscará todo e qualquer elemento dentro dos colchetes (no caso os dígitos numéricos) que apareça uma ou duas vezes (código dentro dos colchetes) e que seja seguido pelo símbolo de porcentagem. Note que esse é o padrão de qualquer uma das porcentagens no nosso string pesquisa. Vamos ver o que acontece se usarmos isso dentro de re.sub().\npesquisa2 = re.sub('[0-9]{1,2}%','ZZZ',pesquisa)\nprint(pesquisa)\nprint(pesquisa2)\nConseguimos exatamente o que a gente queria. Boa, time!\nPare um pouco e pense sobre a aplicabilidade dessa ferramenta dentro de um mundo repleto de dados não-estruturados, como tweets e notícias. O potencial de uso é gigante! Mas como dissemos, o mundo de regex é muito grande e existem cursos e livros que se dedicam integralmente a estudar essa linguagem de padrões textuais. Uma boa referência introdutória é o livro Expressões Regulares: Uma Abordagem Divertida.\nSe eu pudesse dar um conselho para o meu eu de 15 anos atrás seria: beba água e estude expressões regulares.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#listas",
    "href": "objetos.html#listas",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "4.2 Listas",
    "text": "4.2 Listas\nComo uma string, uma lista é uma sequência de valores. Em uma string, os valores são caracteres; em uma lista, eles podem ser de qualquer tipo. Podemos ter uma lista de strings, uma lista de valores numéricos ou mesmo uma lista de listas, combinando strings, números e mesmo outros tipos de objetos que ainda veremos, como tuplas, dicionários e dataframes.\nUma lista é delimitada por colchetes e os elementos, ou itens, pertencentes a ela são separados por vírgula. Para definir uma lista com 5 números inteiros, ordenados de forma sequencial e começando em 1 devemos escrever a seguinte linha de código:\nlista1 = [1,2,3,4,5]\n\nprint(lista1)\nprint(type(lista1))\nPodemos definir uma lista de strings, uma lista mista de strings e números, e uma lista composto por outras listas (lista aninhada):\nlista2 = ['Danilo Souza','Claudio Lucinda']\nlista3 = ['Turma 2024201',46.0,'Turmas 2024202',49,'Turmas 2024221',81]\nlista4 = [lista1, lista2]\n\nprint(lista2)\nprint(lista3)\nprint(lista4)\nDe forma análoga à listas com elementos não vazios, é possível definir uma lista vazia utilizando apenas os colchetes:\nlista_vazia = []\n\nprint(lista_vazia)\n\n4.2.1 Operações básicas\nA sintaxe para acessar os elementos de uma lista é a mesma que para acessar os caracteres de uma string: o operador de colchete. A expressão dentro dos colchetes especifica o índice ou o intervalo de índices. Lembrando que o índice no Python começa em ZERO e não em UM\nprint(lista2[0])\nprint(lista2[1])\nprint(lista3[-1])\nprint(lista3[0:2])\nDiferente das strings, listas são mutáveis. Quando o operador de colchete aparece do lado esquerdo de uma atribuição, ele identifica o elemento da lista que será atribuído:\nnumbers = [42, 123]\nnumbers[1] = 5\nnumbers\nO segundo elemento de numbers (índice 1), que era 123, agora é 5.\nÍndices de listas funcionam da mesma forma que os índices de strings:\n\nQualquer expressão de números inteiros pode ser usada como índice.\nSe tentar ler ou escrever um elemento que não existe, você recebe um IndexError.\nSe um índice tiver um valor negativo, ele conta de trás para a frente, a partir do final da lista.\n\nO operador in, que serve ao propósito de testar a existência de determinado elemento dentro de um objeto específico, também funciona com listas:\ncheeses = ['Cheddar', 'Gorgonzola', 'Gouda']\n'Edam' in cheeses\n'Brie' in cheeses\nAssim como com strings, é possível calcular o número de elementos em uma lista utilizando a função integrada len() e “concatenar” ou “somar” listas utilizando apenas o sinal de +\nprint(len(cheeses))\nlista_soma = lista2 + cheeses\nprint(lista_soma)\n\n\n4.2.2 Métodos de listas\nAs listas também possuem métodos bastante úteis, que nos facilitam a vida em várias dimensões. Dentre os principais métodos aplicáveis a listas e suas funcionalidades podemos citar: \n\nlista_example.append(): adiciona um novo elemento ao fim da lista “lista_example”. \nlista_example.extend(lista2): toma a lista “lista_example” como argumento e adiciona todos os elementos de lista2 como novos elementos da lista inicial. \nlista_example.sort(): classifica os elementos de “lista_example” em ordem ascendente. \nlista_example.remove(x): exclui o elemento igual a “x” de “lista_example”. É um método bastante útil quando queremos excluir um elemento específico, mas não sabemos sua posição dentro da lista. \n\nA maior parte dos métodos de listas são nulos; eles alteram a lista e retornam None. Se você escrever t = t.sort() por acidente, ficará desapontado com o resultado.\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\nAssim como já explicamos, uma lista é uma sequência de valores e uma string é uma sequência de caracteres, mas uma lista de caracteres não é a mesma coisa que uma string. Para converter uma string em uma lista de caracteres, você pode usar o comando list:\ns = 'spam'\nt = list(s)\nprint(t)\nA função list quebra uma string em letras individuais. Se você quiser quebrar uma string em palavras, você pode usar o método split(). Esse método admite um argumento adicional, chamado delimiter, que especifica quais caracteres podem ser usados para demonstrar os limites das palavras. Isso é muito útil, por exemplo, quando queremos separar um texto em palavras e fazer a contagem de palavras que mais se repetem. Qual caracter deveríamos passar como argumento em split() nesse caso?\ns = 'pining for the fjords'\nt = s.split(' ')\nprint(t)\ns = 'spam-spam-spam'\nt = s.split('-')\nt\nO método join() é o contrário de split(). Ele toma uma lista de strings e concatena os elementos. join(), no entanto, é um método de string, então é preciso invocá-lo no string delimitador (por exemplo, ” - “) e passar a lista de strings como parâmetro:\nt = ['spam','spam','spam']\ns = ' - '.join(t)\nprint(s)\nAlém desses principais, existem outros vários métodos para listas. Esse link é um bom ponto de partida para quem quiser conhecer outros exemplos.\n\n\n4.2.3 Operadores lógicos e variáveis booleanas\nAgora faremos um pequeno desvio, que será bem útil daqui para frente, para falar de expressões e variáveis booleanas. Em resumo, uma expressão booleana é uma expressão que pode ser verdadeira ou falsa e dessa forma assumir apenas dois valores como resultado: True e False. Os exemplos seguintes usam o operador de igual no Python (==) que compara dois operandos e produz True se forem iguais e False se não forem:\n5 == 5\n5 == 6\nlista1 = [1,2,3,4,5]\nlista2 = [5,4,3,2,1]\n\nlista1 == lista2\nTrue e False são valores especiais que pertencem ao tipo bool; não são strings. Além disso, é possível fazer operações aritméticas com variáveis do tipo bool já que o Python entende True como sendo equivalente ao número 1 e False como sendo equivalente ao número 0.\nprint(type(True))\nprint(type(False))\nprint(True + True)\nprint(True + False)\nprint(False + False)\nO operador == é um dos operadores relacionais dentro do Python, os outros são:\n\nx != y: x não é igual a y\nx &gt; y: x é maior que y\nx &lt; y: x é menor que y\nx &gt;= y: x é maior ou igual a y\nx &lt;= y: x é menor ou igual a y\n\nEmbora essas operações provavelmente sejam familiares para você, os símbolos do Python são diferentes dos símbolos matemáticos. Um erro comum é usar apenas um sinal de igual (=) em vez de um sinal duplo (==). Lembre-se de que = é um operador de atribuição e == é um operador relacional. Não existe =&gt; ou =&lt;.\nHá três operadores lógicos: and, or e not. A semântica (significado) destes operadores é semelhante ao seu significado em inglês. Por exemplo, x&gt;=0 and x&lt;=10 só é verdade se x for maior que 0 e menor que 10. n%2 == 0 or n%3 == 0 é verdadeiro se uma ou as duas condição(ões) for(em) verdadeira(s), isto é, se o número n for divisível por 2 ou 3 (caso você não esteja familiarizado com a divisão pelo piso e o operador módulo, tente brincar um pouco com // e com %). Finalmente, o operador not nega uma expressão booleana, então not (x &gt; y) é verdade se x &gt; y for falso, isto é, se x for menor que ou igual a y.\nFalando estritamente, os operandos dos operadores lógicos devem ser expressões booleanas, mas o Python não é muito estrito. Qualquer número que não seja zero é interpretado como True:\n42 and True\nEsta flexibilidade tem sua utilidade, mas há algumas sutilezas relativas a ela que podem ser confusas. Assim, pode ser uma boa ideia evitá-la (a menos que você tenha certeza absoluta do que está fazendo).\n\n\n4.2.4 Execução condicional\nPara escrever programas úteis, quase sempre precisamos da capacidade de verificar condições e mudar o comportamento do programa de acordo com elas. Instruções condicionais nos dão esta capacidade. A forma mais simples é a instrução if:\nx=5\n\nif x &gt; 0:\n    print('x é positivo')\nA expressão booleana depois do if é chamada de condição. Se for verdadeira, a instrução indentada é executada. Se não, nada acontece. Aqui vale mais um adendo: uma característica muito importante da sintaxe do Python é justamente a identação. Diferentemente de outras linguagens de programação, a identação exerce papel importante aqui, já que é através dela que se determina onde se inicia e onde termina um bloco de código, que pode ser uma expressão condicional ou mesmo uma função, como veremos mais a frente. Além de economizar várias chaves (“{” e “}”) e vários “end”, a identação exerce um papel estético importante ao permitir uma melhor visualização do código como um todo.\nNão há limite para o número de instruções que podem aparecer no corpo de uma instrução if, mas deve haver pelo menos uma. Ocasionalmente, é útil ter um corpo sem instruções (normalmente como um espaço reservado para código que ainda não foi escrito). Neste caso, você pode usar a instrução pass, que não faz nada.\nif x &lt; 0:\n    pass \n\n\n4.2.5 Execução alternativa\nUma segunda forma da instrução if é a “execução alternativa”, na qual há duas possibilidades e a condição determina qual será executada. A sintaxe pode ser algo assim:\nx = 5\n\nif x % 2 == 0:\n    print('x é par')\nelse:\n    print('x é ímpar')\nSe o resto quando x for dividido por 2 for 0, então sabemos que x é par e o programa exibe uma mensagem adequada. Se a condição for falsa, o segundo conjunto de instruções é executado. Como a condição deve ser verdadeira ou falsa, exatamente uma das alternativas será executada. As alternativas são chamadas de ramos (branches), porque são ramos no fluxo da execução.\nPodemos usar a instrução if para testar o tamanho de uma lista também:\nlista1 = [1,2,3,4,5]\n\nif len(lista1) &gt; 2:\n    print('lista1 tem mais de dois elementos')\nelse:\n    print('lista1 tem menos de dois elementos')\n\n\n4.2.6 Condicionais encadeadas\nÀs vezes, há mais de duas possibilidades e precisamos de mais que dois ramos. Esta forma de expressar uma operação de computação é uma condicional encadeada:\nx = 5\ny = 6\n\nif x &lt; y:\n    print('x é menor do que y')\nelif x &gt; y:\n    print('x é maior do que y')\nelse:\n    print('x e y são iguais')\nelif é uma abreviatura de “else if”. Novamente, exatamente um ramo será executado. Não há nenhum limite para o número de instruções elif. Se houver uma cláusula else, ela deve estar no fim, mas não é preciso haver uma. Cada condição é verificada em ordem. Se a primeira for falsa, a próxima é verificada, e assim por diante. Se uma delas for verdadeira, o ramo correspondente é executado e a instrução é encerrada. Mesmo se mais de uma condição for verdade, só o primeiro ramo verdadeiro é executado.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#tuplas",
    "href": "objetos.html#tuplas",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "4.3 Tuplas",
    "text": "4.3 Tuplas\nAgora falaremos de mais um tipo de objeto básico do Python, a tupla. Uma tupla é uma sequência de valores. Os valores podem ser de qualquer tipo, e podem ser indexados por números inteiros, portanto, nesse sentido, as tuplas são muito parecidas com as listas. A diferença importante é que as tuplas são imutáveis, assim como os strings.\nEm resumo, uma tupla é uma lista de valores separados por vírgulas e em geral delimitado por parênteses (lembre que listas são delimitadas por colchetes):\nt = ('a', 'b', 'c', 'd', 'e')\n\nprint(type(t))\nUm único valor entre parênteses não é uma tupla. Para criar uma tupla com um único elemento, é preciso incluir uma vírgula final após o elemento, com ou sem os parênteses.\nt1 = ('a')\nt2 = 'a',\nt3 = ('a',)\n\nprint(type(t1))\nprint(type(t2))\nprint(type(t3))\nOutra forma de criar uma tupla é com a função integrada tuple. Sem argumentos, cria uma tupla vazia. Se os argumentos forem uma sequência (string, lista ou tupla), o resultado é uma tupla com os elementos da sequência:\nt = tuple()\nprint(t)\nt = tuple('lupins')\nprint(t)\n\n4.3.1 Operações básicas\nA maior parte dos operadores de lista também funciona em tuplas. O operador de colchetes indexa um elemento e o operador de fatia seleciona vários elementos.\nt = ('a', 'b', 'c', 'd', 'e')\nprint(t[0])\nprint(t[1:3])\nEntretanto, se tentar alterar um dos elementos da tupla, vai receber um erro:\nt[0] = 'A'\nComo tuplas são imutáveis, você não pode alterar os elementos, mas pode substituir uma tupla por outra.\nt = ('A',) + t[1:]\nprint(t)\nOs operadores relacionais funcionam com tuplas e outras sequências. O Python começa comparando o primeiro elemento de cada sequência. Se forem iguais, vai para os próximos elementos, e assim por diante, até que encontre elementos que sejam diferentes. Os elementos subsequentes não são considerados (mesmo se forem muito grandes).\n(0, 1, 2) &lt; (0, 3, 4)\n(0, 1, 2000000) &lt; (0, 3, 4)\n\n\n4.3.2 Atribuição de tuplas\nMuitas vezes, é útil trocar os valores de duas variáveis. Com a atribuição convencional, é preciso usar uma variável temporária. Por exemplo, trocar a e b.\na=5\nb=6\n\ntemp = a\na = b\nb = temp\n\nprint(b)\nEssa solução é trabalhosa; a atribuição de tuplas é mais elegante:\na=5\nb=6\n\na, b = b, a\n\nprint(b)\nO lado esquerdo é uma tupla de variáveis e o lado direito é uma tupla de expressões. Cada valor é atribuído à sua respectiva variável. Todas as expressões no lado direito são avaliadas antes de todas as atribuições.\nO número de variáveis à esquerda e o número de valores à direita precisam ser iguais:\na, b = 1, 2, 3\nDe forma geral, o lado direito pode ter qualquer tipo de sequência (string, lista ou tupla). Por exemplo, para dividir um endereço de email em um nome de usuário e um domínio, você poderia escrever:\naddr = 'monty@python.org'\nuname, domain = addr.split('@')\nO valor de retorno do split() é uma lista com dois elementos; o primeiro elemento é atribuído a uname, o segundo a domain:\nprint(uname)\nprint(domain)\n\n\n4.3.3 Tuplas como valores de retorno\nFalando estritamente, uma função só pode retornar um valor, mas se o valor for uma tupla, o efeito é o mesmo que retornar valores múltiplos. Por exemplo, se você quiser dividir dois números inteiros e calcular o quociente e resto, não é eficiente calcular x/y e depois x%y. É melhor calcular ambos ao mesmo tempo. A função integrada divmod toma dois argumentos e devolve uma tupla de dois valores: o quociente e o resto da divisão do primeiro termo pelo segundo termo. Você pode guardar o resultado como uma tupla:\nprint(7//3)\nprint(7%3)\nt = divmod(7, 3)\n\nprint(t)\nprint(type(t))\n\n\n4.3.4 Operações nativas com tuplas\nzip é uma função integrada que recebe duas ou mais sequências e devolve uma lista de tuplas onde cada tupla contém um elemento de cada sequência. O nome da função tem a ver com o zíper, que se junta e encaixa duas carreiras de dentes.\nEste exemplo encaixa uma string e uma lista:\ns = 'abc'\nt = [0, 1, 2]\nzip(s,t)\nO resultado é um objeto zip que sabe como percorrer os pares. O uso mais comum de zip é em um loop for (falaremos sobre loops mais adiante no curso):\nfor pair in zip(s, t):\n    print(pair)\nUm objeto zip é um tipo de iterador, ou seja, qualquer objeto que percorre ou itera sobre uma sequência. Iteradores são semelhantes a listas em alguns aspectos, mas, ao contrário de listas, não é possível usar um índice para selecionar um elemento de um iterador. Se quiser usar operadores e métodos de lista, você pode usar um objeto zip para fazer uma lista:\nlist(zip(s, t))\nO resultado é uma lista de tuplas. Neste exemplo, cada tupla contém um caractere da string e o elemento correspondente da lista. Se as sequências não forem do mesmo comprimento, o resultado tem o comprimento da mais curta:\nlist(zip('Anne', 'Elk'))",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#dicionários",
    "href": "objetos.html#dicionários",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "4.4 Dicionários",
    "text": "4.4 Dicionários\nDicionários são um outro tipo de objeto bastante importante e útil em nossas aplicações. Dicionários são um dos melhores recursos do Python, eles são os blocos de montar de muitos algoritmos eficientes e elegantes.\nUm dicionário se parece com uma lista, mas é mais geral. Em uma lista os índices têm que ser números inteiros, em um dicionário eles podem ser de (quase) qualquer tipo. Um dicionário contém uma coleção de índices, que se chamam chaves e uma coleção de valores. Cada chave é associada com um único valor. A associação de uma chave e um valor chama-se par chave-valor ou item.\nEm linguagem matemática, um dicionário representa um mapeamento de chaves a valores, para que você possa dizer que cada chave “mostra o mapa” a um valor. Como exemplo, vamos construir um dicionário que faz o mapa de palavras do inglês ao espanhol, portanto as chaves e os valores são todos strings.\nA função dict cria um novo dicionário sem itens. Como dict é o nome de uma função integrada, você deve evitar usá-lo como nome de variável.\neng2sp = dict()\neng2sp\nAs chaves {} representam um dicionário vazio. Para acrescentar itens ao dicionário, você pode usar colchetes:\neng2sp['one'] = 'uno'\nEsta linha cria um item que mapeia da chave ‘one’ ao valor ‘uno’. Se imprimirmos o dicionário novamente, vemos um par chave-valor com dois pontos entre a chave e o valor:\neng2sp\nEste formato de saída também é um formato de entrada. Por exemplo, você pode criar um dicionário com três itens:\neng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\neng2sp\nUé, mas a ordem parece diferente daquela que definimos, não? Se você digitar o mesmo exemplo no seu computador, pode receber um resultado diferente. Em geral, a ordem dos itens em um dicionário é imprevisível. No entanto, isso não é um problema porque os elementos de um dicionário nunca são indexados com índices de números inteiros. Em vez disso, você usa as chaves para procurar os valores correspondentes. A chave 'two', por exemplo sempre mapeia ao valor 'dos', assim a ordem dos itens não importa.\neng2sp['two']\nSe a chave não estiver no dicionário, você recebe uma exceção:\neng2sp['four']\nAssim como em strings e listas, a função len também é compatível com dicionários. Nesse caso ela devolve o número de pares chave-valor.\nlen(eng2sp)\nO operador in funciona em dicionários também. Ele acusa se algo aparece como chave no dicionário (aparecer como valor não é o suficiente).\n'one' in eng2sp\n'uno' in eng2sp\nPara ver se algo aparece como um valor em um dicionário, você pode usar o método values(), que devolve uma coleção de valores, e então usar o operador in:\nvals = eng2sp.values()\n'uno' in vals\n\n4.4.1 Operações básicas\nPodemos adicionar um novo par de chave e valor ao dicionário usando colchetes, mas caso a chave já exista no dicionário, podemos atualizar o valor.\ny = {}\ny['one'] = 1\ny['two'] = 2\nprint(y)\ny['two'] = 'dos'\nprint(y)\nO valor-chave deve ser um tipo de dados imutável, por essa razão, se você tentar definir um dicionário com um tipo de dados mutável, o Python levantará um erro de exceção.\nA instrução del pode ser usada para remover uma entrada (par de valor de chave) de um dicionário.\ny = {'one': 1, 'two': 2}\nprint(y)\ndel y['two']\nprint(y)\nMais uma vez, podemos utilizar a função nativa len para retornar o número de entradas (pares de valor de chave) em um dicionário.\nx = {'one': 0, 'two': 2}\nprint(len(x))\nTente acessar uma chave que não está em um dicionário e você receberá um erro de exceção do Python. Para lidar com essa exceção, você pode usar mais uma vez o operador in que testa se existe uma chave em um dicionário. Esse operador retorna True se o dicionário tiver um valor armazenado sob a chave fornecida e Falso caso contrário.\ny = {'one': 1, 'two': 2}\ndel y['three']\n'three' in y\n\n\n4.4.2 Métodos de dicionários\nDentre os principais métodos aplicáveis a dicionários e suas funcionalidades podemos citar: \n\ndict_example.update(x): atualiza o dicionário “dict_example” com todos os pares de valor-chave de um segundo dicionário “x”. Os valores de chaves, que são comuns a ambos os dicionários, do segundo dicionário irão se sobrepor aos valores das chaves do primeiro dicionário. \ndict_example.keys(x): permite que você obtenha todas as chaves no dicionário. Muitas vezes é usado dentro de uma série de instruções repetida várias vezes para iterar sobre o conteúdo de um dicionário. \ndict_example.items(): retorna todas as chaves do dicionário “dict_example” e seus valores associados como uma sequência de tuplas. \ndict_example.get(x,y): devolve o valor associado a uma chave “x” se o dicionário contiver essa chave. Caso o dicionário não contenha a chave, você pode especificar um segundo argumento opcional “y” para retornar um valor padrão (se o argumento não estiver incluído o método retornará None). \ndict_example.setdefault(x,y): é semelhante ao método get(): ele retorna o valor associado a uma chave “x” se o dicionário contiver essa chave, mas caso o dicionário não contenha a chave, este método criará um novo elemento no dicionário (par de valor de chave), onde o primeiro argumento neste método é a chave, e o segundo argumento (“y”) é o valor. O segundo argumento é opcional, mas se isso não for incluído, o valor atrelado a essa nova chave será None. \n\nAlém desses principais, existem outros vários métodos para dicionários. Esse link é um bom ponto de partida para quem quiser conhecer outros exemplos.\nx = {'one': 0, 'two': 2}\ny = {'one': 1, 'three': 3}\nprint(x)\n\nx.update(y)\nprint(x)\nx = {'one': 1, 'two': 2}\nprint(x.keys())\nx = {'one': 1, 'two': 2}\nprint(x.items())\ny = {'one': 1, 'two': 2}\nprint(y.get('one'))\nprint(y.get('three'))\nprint(y.get('three', 'The key does not exist.'))\ny = {'one': 1, 'two': 2}\nprint(y.setdefault('three', '3'))\nprint(y.setdefault('two', 'dos'))\nprint(y)\nprint(y.setdefault('four'))\nprint(y)",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "objetos.html#exercícios",
    "href": "objetos.html#exercícios",
    "title": "4  Tipos primitivos e objetos básicos",
    "section": "4.5 Exercícios",
    "text": "4.5 Exercícios\n\nConsidere a seguinte lista: fruit = ['pear', 'orange', 'apple', 'grapefruit', 'apple', 'pear']. Use uma função de lista para dizer o índice da primeira ocorrência de apple\nUsando a lista do exercício anterior, use uma função de lista para retornar o número de veze que apple ocorre.\nExistem duas listas abaixo. Escreva um programa que as converta em um dicionário em que o item de keys é a chave e o item de values é o valor\n\nkeys = ['Ten', 'Twenty', 'Thirty']\nvalues = [10, 20, 30]\nOutput esperado do último exercício\n{'Ten': 10, 'Twenty': 20, 'Thirty': 30}",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos primitivos e objetos básicos</span>"
    ]
  },
  {
    "objectID": "iteracao.html",
    "href": "iteracao.html",
    "title": "5  Controle de fluxo e iteração",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Controle de fluxo e iteração</span>"
    ]
  },
  {
    "objectID": "funcoes.html",
    "href": "funcoes.html",
    "title": "6  Funções",
    "section": "",
    "text": "6.1 O que é uma função?\nIn summary, this book has no content whatsoever.\nNo contexto das linguagens de programação, uma função é uma sequência nomeada de instruções, que executa algum tipo de operação específica mas não necessariamente numérica, como é o caso das funções matemáticas. A ideia essencial por trás de uma função é a de juntar algumas tarefas comuns ou repetidas e criar uma função para que, em vez de escrever o mesmo código várias vezes, possamos chama-la pelo nome e reutilizar o conjunto de instruções nela contida sempre que necessário.\nCaso o objetivo de dividir um programa em funções ainda não tenha ficado claro, saiba que:\nExistem várias funções nativas no Python (e.g., type() para encontrar o tipo de um objeto) e mesmo dentro de bibliotecas com as quais já trabalhamos um pouco (e.g., numpy.random.uniform() para sortear números aleatórios de acordo com uma distribuição uniforme). À partir de agora veremos como podemos criar nossas próprias funções dentro da linguagem!\nNo Python, a sintaxe de uma função é dada por:\nAssim como nos loops, para definir uma nova função no Python é preciso começar com uma palavra-chave, nesse caso def. O nome que daremos à função vem logo em seguida. É através desse nome, nome_da_funcao, que chamaremos essa função em outras partes do nosso código. Entre parênteses definimos os argumentos que a função recebe para realizar o conjunto de instruções em &lt;instruções&gt;.\nNote, mais uma vez, que todo o bloco de código que estiver identado e abaixo da linha de cabeçalho da função fará parte da função. Assim como nos loops, a função termina quando passarmos a primeira linha de código não-identada.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#o-que-é-uma-função",
    "href": "funcoes.html#o-que-é-uma-função",
    "title": "6  Funções",
    "section": "",
    "text": "Criar uma nova função dá a oportunidade de nomear um grupo de instruções, o que deixa o seu programa mais fácil de ler e de depurar\nAs funções podem tornar um programa menor, eliminando o código repetitivo. Depois, caso precise fazer alguma alteração, basta fazê-la em um lugar só.\nDividir um programa longo em funções permite depurar as partes uma de cada vez e então reuni-las em um conjunto funcional.\nAs funções bem projetadas muitas vezes são úteis para muitos programas. Uma vez escritas e depuradas, você pode reutilizar as funções em programas fora daquele para o qual elas foram originalmente construídas.\n\n\n\n\ndef nome_da_funcao(argumentos):\n    &lt;instruções&gt;",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#nossa-primeira-função",
    "href": "funcoes.html#nossa-primeira-função",
    "title": "6  Funções",
    "section": "6.2 Nossa primeira função",
    "text": "6.2 Nossa primeira função\nVamos começar criando uma função simples, que tem por objetivo printar uma das frases mais conhecidas da história do cinema:\ndef frase_cinema():\n    print('Que a força esteja com você!')\nNote que nesse caso, o parênteses logo após o nome da função está vazio. Isso quer dizer que essa função não recebe argumentos, apenas printa a frase entre aspas sempre que for chamada. Para chamá-la, basta usar o nome frase_cinema seguido dos parênteses vazios:\nfrase_cinema()",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#argumentos-de-uma-função",
    "href": "funcoes.html#argumentos-de-uma-função",
    "title": "6  Funções",
    "section": "6.3 Argumentos de uma função",
    "text": "6.3 Argumentos de uma função\nNa função anterior, não tínhamos nenhum argumento. Ou seja, toda vez que você chamar a função frase_cinema, ela vai fazer a mesma coisa. Pode até ser que seja o seu objetivo fazer exatamente isso – é uma forma de economizar código.\nO ponto é que a ideia de função é muito mais poderosa do que simplesmente uma “abreviação” de um monte de linhas de código. A abstração implícita no conceito de função é poderosa o suficiente para garantir que a função retorne coisas diferentes caso você altere algum argumento. Vamos falar disso a seguir.\n\n6.3.1 Keyword arguments e default values\nVamos então criar uma função que tenha argumentos.\ndef my_func(name,place):\n    print(f\"Olá {name}! Você é de {place}?\")\n\nmy_func(\"Emily\",\"Paris\")\nO que acontece se você especificar o place primeiro e depois o name? Vamos descobrir.\nmy_func(\"Hawaii\",\"Robert\")\nMeio bizarro, não? A razão é que aqui temos os chamados argumentos posicionais. Ou seja, a função vai assumir que o primeiro argumento é o name e o segundo é o place não importa o que tenhamos passado como argumento. Para lidar com isso, a gente pode atribuir um nome a cada um dos argumentos, ou palavra-chave, que aí vai ser a palavra-chave, e não a posição, que vai determinar qual o valor atribuído a cada argumento.\nmy_func(place=\"Hawaii\",name=\"Robert\")\nVimos aqui que a posição passou a ser irrelevante porque colocamos os nomes de cada um dos argumentos. E se quiséssemos dar mais flexibilidade ainda à função, só especificando um subconjunto dos argumentos? Para que isso funcione, nós precisamos especificar os valores-padrão dos argumentos caso eles não sejam fornecidos.\nAqui tem uma função que faz isso.\ndef total_calc(bill_amount,tip_perc=10):\n    \n    total = bill_amount*(1 + tip_perc/100)\n    total = round(total,2)\n    print(f\"Please pay ${total}\")\nNesse caso, o argumento bill_amount é obrigatório. Por outro lado, o argumento tip_perc vai assumir o valor de 10 toda vez que ele não for explicitamente fornecido na chamada da função.\n\n\n6.3.2 Argumentos arbitrários\nVamos começar fazendo algumas perguntas: * E se não soubermos o número exato de argumentos de antemão? * Podemos criar funções que funcionem com um número variável de argumentos?\nA resposta é sim! E vamos criar essa função imediatamente. Vamos criar uma função simples my_var_sum() que retorna a soma de todos os números passados como argumento. No entanto, o número de argumentos pode ser potencialmente diferente cada vez que chamamos a função.\ndef my_var_sum(*args):\n    \n    sum = 0\n    for arg in args:\n        sum += arg\n        \n    print(f\"The numbers that you have add up to {sum}\")\nObserve como a definição da função agora tem *args em vez de apenas o nome do parâmetro. No corpo da função, fazemos um loop em args até usarmos todos os argumentos. A função my_var_sum retorna a soma de todos os números passados como argumentos. Olha só o que acontece quando chamamos a função com diferentes números de argumentos:\nmy_var_sum(99,10,54,23)\nmy_var_sum(9,87)\nmy_var_sum(5,21,36,79,45,65)\nmy_var_sum(1)\nMas e se eu quiser passar não apenas uma sequência de valores, mas uma sequência de valores com nomes? Não se preocupe, existe uma possibilidade de fazer isso, usando o **kwargs na definição dos argumentos. Qual é a diferença entre *args e **kwargs? A diferença é que você vai passar uma sequência de tamanho arbitrário de parâmetros, cada um deles nomeado.\nO Python vai entender o **kwargs como um dicionário. Cada elemento passado é um par chave-valor, e dentro da função você tem que desempacotar o valor da chave. Vamos seguir alguns exemplos.\ndef myFun(**kwargs):\n    \n    for key, value in kwargs.items():\n        print(\"%s == %s\" % (key, value))\n \n \nmyFun(first='Geeks', mid='for', last='Geeks')\nPodemos misturar os tipos de argumentos (posicionais versus *args/*kwargs)? Sim, como podemos ver no exemplo seguinte:\ndef myFun(arg1, **kwargs):\n    \n    for key, value in kwargs.items():\n        print(arg1+\" %s == %s\" % (key, value))\n \n \nmyFun(\"Hi - \", first='Geeks', mid='for', last='Geeks')\n\n\n6.3.3 Elementos dentro da função: execução condicional\nAs funções podem retornar objetos booleanos também, o que pode ser conveniente para esconder testes complicados dentro de funções. Por exemplo:\ndef is_divisible(x, y):\n    \n    if x % y == 0:\n        print(True)\n    else:\n        print(False)\n    \nis_divisible(6, 4)\n\n\n6.3.4 Aplicação: Teorema Central do Limite - Parte 1\nO primeiro passo para replicarmos, na forma de uma função, a aplicação do Teorema Central do Limite da aula anterior é definir uma função que recebe como argumentos a distribuição da varíavel aleatória X, o intervalo no qual a variável está definida e o número de sorteios que faremos em cada amostra. Com o que aprendemos até agora podemos definir a função func_tcl abaixo:\ndef func_tcl(dist=None,intervalo=(0,1),n=100):\n    \n    if dist == None:\n        print('Você esqueceu de carregar uma função que defina a distribuição de X! Volte 2 casas.')\n    else:\n        x = dist(intervalo[0],intervalo[1],n)\n        print(x)\nPara todos os 3 argumentos definimos valores default que, caso não sejam alterados a função vai utilizá-los em suas operações. Vamos rodar a função com todos os valores default e ver o que acontece:\nfunc_tcl()\nNesse caso, a execução condicional if dentro da função acende já que não passamos nenhuma distribuição como default, apenas o valor None. Vamos então repetir o que fizemos na aula passada e utilizar a distribuição uniforme, no intervalo \\(\\left[-40,40\\right]\\) e sorteando apenas 10 números desta distribuição:\nfunc_tcl(dist=np.random.uniform,intervalo=(-40,40),n=10)\n\n\n6.3.5 Elementos dentro da função: iteração\nDa mesma forma que podemos ter condições lógicas dentro da função, podemos ter blocos de repetição (for e while) dentro da função, assim como no caso de *args. Vamos olhar para um outro exemplo em que a função recebe uma lista de strings como argumento e faz operações em cada um dos elementos, um a um:\nstates = [' Alabama ','Georgia!','Georgia','georgia','FlOrIda','south carolina##','West virginia?']\n\ndef clean_strings(lista_strings):\n    result=[]\n    \n    for value in lista_strings:\n        value = value.strip()\n        value = value.title()\n        value = value.replace('#','')\n        value = value.replace('?','')\n        value = value.replace('!','')\n        result.append(value)\n    \n    print(result)\n\nprint(states)\nprint()\nclean_strings(states)\n\n\n6.3.6 Aplicação: Teorema Central do Limite - Parte 2\nAgora podemos dar mais um passo e incorporar o loop dentro da função, passando como novo argumento da função o número de amostras com o qual queremos trabalhar:\ndef func_tcl(dist=None,intervalo=(0,1),n=100, samples=10):\n    \n    if dist == None:\n        print('Você esqueceu de carregar uma função que defina a distribuição de X!')\n    else:\n        means = []\n        for j in range(0,samples):\n            x_func_tcl = dist(intervalo[0],intervalo[1],n)\n            mean_x = sum(x_func_tcl)/len(x_func_tcl)\n            \n            means.append(mean_x)\n        \n        print('Essa é a lista de médias:')\n        print(means)\n        print('\\nE essa é a média das médias:')\n        print(sum(means)/len(means))\n# utilizamos a função seed mais uma vez para tornar os resultados previsíveis\nnp.random.seed(1)\n\nfunc_tcl(dist=np.random.uniform,intervalo=(-40,40),n=50,samples=10)\nQue bacana!!!\nMas note que o valor da média que nos interessa nesse caso só aparece printado quando chamamos a função. O que podemos fazer para conseguir guardá-lo como uma nova variável, por exemplo?",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#valor-de-retorno-de-uma-função",
    "href": "funcoes.html#valor-de-retorno-de-uma-função",
    "title": "6  Funções",
    "section": "6.4 Valor de retorno de uma função",
    "text": "6.4 Valor de retorno de uma função\nO comando return é usado para a saída de uma função de volta ao lugar no código de onde ela foi chamada. A sintaxe desse comando é simples:\nreturn &lt;expression_list&gt;\nEssa declaração pode ter um comando que é executado e o valor resultante devolvido. Se esse comando não for anexado ou não tiver nada além do return, a função é devolvida com o valor de None. Por exemplo:\ndef my_func(name,place):\n    \n    print(f\"Olá {name}! Você é de {place}?\")\n    return\n\nprint(my_func(\"Jane\",\"Paris\"))\nFunções que não contenham o comando return sempre retornarão um valor vazio. Quando queremos utilizar uma função com o objetivo de realizar algum tipo de operação e guardar o valor dessa operação, não podemos esquecer do return. Vejamos o exemplo da função que calcula a raiz quadrada de um número:\ndef raiz(x):\n    \n    fx = x**0.5\n\ny = raiz(100)\nprint(y)\ndef raiz(x):\n    \n    fx = x**0.5\n    return fx\n\ny = raiz(100)\nprint(y)\n\n6.4.1 Expectativa de vida de variáveis dentro da função\nQuando você cria uma variável dentro de uma função ela é local, ou seja, só existe dentro da própria função. Por exemplo:\ndef concat_strings(str1,str2):\n    \n    texto_concatenado = str1 + ' ' + str2\n    print(texto_concatenado)\n    \n\ntexto1 = 'Que a força esteja com você,'\ntexto2 = 'jovem Padawan.'\n\nconcat_strings(texto1,texto2)\nEssa função recebe dois argumentos, concatena-os e exibe o resultado em uma única linha de texto. No entanto, assim que a função é encerrada, a variável texto_concatenado é deletada. O que acontece se tentarmos acessá-la?\nprint(texto_concatenado)\n\n\n6.4.2 Aplicação: Teorema Central do Limite - Parte 3\nRetomando a função da parte 2:\ndef func_tcl(dist=None,intervalo=(0,1),n=100, samples=10):\n    \n    if dist == None:\n        print('Você esqueceu de carregar uma função que defina a distribuição de X!')\n    else:\n        means = []\n        for j in range(0,samples):\n            x_func_tcl = dist(intervalo[0],intervalo[1],n)\n            mean_x = sum(x_func_tcl)/len(x_func_tcl)\n            \n            means.append(mean_x)\n            mean_of_means = sum(means)/len(means)\n        \n        print('Essa é a lista de médias:')\n        print(means)\n        print('\\nE essa é a média das médias:')\n        print(mean_of_means)\nnp.random.seed(1)\n\nfunc_tcl(dist=np.random.uniform,intervalo=(-40,40),n=50,samples=10)\nComo acabamos de ver, se quisermos acessar a variável mean_of_means o Python retornará um erro. As variáveis definidas dentro de uma função tem vida curta: elas existem apenas dentro da função!\nprint(mean_of_means)\nNo entanto, agora já sabemos o que a palavra-chave return faz dentro de uma função. Vamos utilizá-la!\ndef func_tcl(dist=None,intervalo=(0,1),n=100, samples=10):\n    \n    if dist == None:\n        print('Você esqueceu de carregar uma função que defina a distribuição de X!')\n    else:\n        means = []\n        for j in range(0,samples):\n            x_func_tcl = dist(intervalo[0],intervalo[1],n)\n            mean_x = sum(x_func_tcl)/len(x_func_tcl)\n            \n            means.append(mean_x)\n            mean_of_means = sum(means)/len(means)\n        \n        return mean_of_means\nnp.random.seed(1)\n\nfunc_tcl(dist=np.random.uniform,intervalo=(-40,40),n=50,samples=10)\nMaravilha, agora a função nos retorna apenas o que é do nosso interesse: a média das médias. Para chegar, finalmente, no mesmo resultado da aula passada basta colocar essa função dentro de um loop e tacar-lhe pau nesse carrinho, Marcos!\nexpoentes = [1,2,3,4,5,6,7,8,9,10]\nY = [2**exp for exp in expoentes]\n\nmeans_of_means = []\n\nnp.random.seed(1)\nfor y in Y:\n\n    mean_of_means = func_tcl(dist=np.random.uniform,intervalo=(-40,40),n=100,samples=y)\n    means_of_means.append(mean_of_means)\nimport numpy as np\nfor m in means_of_means:\n    \n    print(np.round(m,2))\nVoilá!\nComo exercício para casa, tente fazer alterações nessa função de modo que ela receba não um valor com o número de amostras, mas uma lista de números de amostras. A função deve cuspir como resultado a lista means_of_means e não apenas o valor mean_of_means. Pratique!",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#documentação",
    "href": "funcoes.html#documentação",
    "title": "6  Funções",
    "section": "6.5 Documentação",
    "text": "6.5 Documentação\nUma docstring é uma string no início de uma função, definida pelo usuário, que serve como documentação do que a função faz. A docstring vem logo depois da primeira linha que define a função e é delimitada por aspas triplas, o que permite que a string se estenda por várias linhas, como vocês devem se lembrar.\nVamos criar como exemplo uma função que printa o tipo do objeto que é passado como argumento:\ndef imprime_tipo(x):\n    \n    '''\n    Função criada para a matéria EAE1106 - Métodos Computacionais para Economia\n    Objetivo: função simples que imprime o tipo do objeto recebido como argumento.\n    '''\n    \n    print(type(x))\nEmbora opcional, a documentação é uma boa prática de programação. A menos que você consiga se lembrar qual foi o cardápio do bandejão na semana passada, sempre documente seu código. Podemos acessar a documentação de determinada função utilizando o atributo __doc__.\nprint(imprime_tipo.__doc__)\nIsso vale também para funções nativas e definidas em outros pacotes do Python. Por exemplo,\n# documentação da função nativa len()\nprint(len.__doc__)\nimport time\n\n# documentação da função time() dentro do pacote time\nprint(time.time.__doc__)\nimport numpy as np\n\n# documentação da função uniform() dentro do pacote NumPy\nprint(np.random.uniform.__doc__)\nNote do exemplo acima que uma docstring pode conter uma descrição detalhada do funcionamento de uma função, inclusive com exemplos de aplicação. Legal, né? Esse tipo de documentação também está disponível para as bibliotecas como um todo. Isso pode nos ajudar, por exemplo, a conhecer o conteúdo de uma determinada biblioteca.\nimport numpy as np\n\n# documentação do NumPy\nprint(np.__doc__)\nPodemos usar sempre esse atalho caso desejemos conhecer as funcionalidades que uma biblioteca guarda por trás de suas cortinas!",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "funcoes.html#funções-anônimas",
    "href": "funcoes.html#funções-anônimas",
    "title": "6  Funções",
    "section": "6.6 Funções anônimas",
    "text": "6.6 Funções anônimas\nEm Python, uma função anônima é uma função definida sem nome. Quem poderia imaginar, não é mesmo?\nEnquanto as funções normais são definidas usando a palavra-chave def em Python, as funções anônimas são definidas usando a palavra-chave lambda. Portanto, funções anônimas também são chamadas de funções lambda. A estrutura usual de uma função lambda é a seguinte:\nlambda &lt;argumentos&gt;: &lt;expressão&gt;\nUsualmente a gente precisa de uma função lambda porque precisamos de uma função rápida por um período de tempo e/ou quando a gente usa técnicas mais poderosas que possuem funções como argumento, como filter e map. Vou fazer um exemplo com cada uma delas.\n\nUsando filter\nA função filter() em Python recebe uma função e uma lista como argumentos. A função é chamada com todos os itens da lista e uma nova lista é retornada contendo itens para os quais a função avalia True. Aqui está um exemplo de uso da função para filtrar apenas números pares de uma lista.\nmy_list = [1, 5, 4, 6, 8, 11, 3, 12]\n\nnew_list = list(filter(lambda x: (x%2 == 0) , my_list))\n\nprint(new_list)\nUsando map\nA função map() em Python recebe uma função e uma lista. A função é chamada com todos os itens da lista e uma nova lista é retornada contendo os itens retornados por essa função para cada item. Aqui está um exemplo de uso da função map() para dobrar todos os itens em uma lista.\nmy_list = [1, 5, 4, 6, 8, 11, 3, 12]\n\nnew_list = list(map(lambda x: x * 2 , my_list))\n\nprint(new_list)",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções</span>"
    ]
  },
  {
    "objectID": "pacotes.html",
    "href": "pacotes.html",
    "title": "Computação numérica, análise de dados e visualização",
    "section": "",
    "text": "Este é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Computação numérica, análise de dados e visualização"
    ]
  },
  {
    "objectID": "numpy.html",
    "href": "numpy.html",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "",
    "text": "7.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental para computação científica em Python. Essa biblioteca é peça fundamental em outras bibliotecas igualmente importantes, como o Pandas e o Matplotlib. É uma biblioteca Python que tem como principal objeto o ndarray, um array multidimensional que guarda bastante semelhança com a ideia de vetores e matrizes, embora seja um objeto específico dentro da linguagem, com suas características e métodos próprios. O pacote contém também uma variedade de rotinas para operações rápidas em arrays, incluindo matemática, lógica, álgebra linear básica, operações estatísticas básicas e muito mais.\nMas o que é de fato um ndarray? É um objeto multidimensional que nos permite armazenar dados de forma sequencial e que podem ser acessados via indexação. Ué, mas isso é muito parecido com uma lista (ou um conjunto de listas). Qual a diferença então?\nSão muitas as qualidades do NumPy que fazem dele a melhor escolha quanto o assunto é lidar com objetos sequenciais, multidimensionais, e com os quais queremos operar tal qual vetores e matrizes. Mas chega de lenga lenga, vamos ao trabalho!",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#o-que-é-o-numpy",
    "href": "numpy.html#o-que-é-o-numpy",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "",
    "text": "NumPy arrays têm um tamanho fixo na criação, ao contrário das listas, que podem crescer. Alterar o tamanho de um ndarray criará um novo array e excluirá o original.\nTodos os elementos em um array devem ser do mesmo tipo de dados, diferentemente de listas, que são objetos mais genéricos. Isso facilita a gestão de memória e torna operações com esse tipo de objeto ordens de magnitude mais rápidas do que se utilizássemos listas.\nA maior velocidade e eficiência de armazenamento fazem do NumPy uma das bibliotecas mais utilizadas em aplicações matemáticas e científicas. Saber apenas as ferramentas nativas do Python, como listas, hoje já não é mais suficiente.",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#elementos-básicos-do-numpy",
    "href": "numpy.html#elementos-básicos-do-numpy",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "7.2 Elementos básicos do NumPy",
    "text": "7.2 Elementos básicos do NumPy\nAntes de tudo, é preciso importar o NumPy, já que se trata de uma biblioteca não nativa do Python.\n\nimport numpy as np\n\n\n7.2.1 Arrays unidimensionais\nComecemos criando um numpy.ndarray do zero, contendo os números 1, 2 e 3. Podemos fazê-lo da seguinte forma:\n\na = np.array([1, 2, 3])\nprint(a)\nprint(type(a))\n\n[1 2 3]\n&lt;class 'numpy.ndarray'&gt;\n\n\nA sintaxe é essa mesma: um par de colchetes dentro dos parênteses. Se tentarmos passar sem os colchetes, o Python retornará um erro.\n\na = np.array(1, 2, 3)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 a = np.array(1, 2, 3)\n\nTypeError: array() takes from 1 to 2 positional arguments but 3 were given\n\n\n\nDa mesma forma que uma sequência de 3 números inteiros, podemos criar um numpy.ndarray que repete 3 vezes o número 0 ou 3 vezes o número 1.\n\na = np.zeros(3)\nb = np.ones(3)\n\nprint(a)\nprint(b)\n\n[0. 0. 0.]\n[1. 1. 1.]\n\n\nNote que em ambos os casos os números aparecem com o ponto da casa decimal, o que é um indicativo de que estão armazenados como valores do tipo float. E se quiséssemos criar esses mesmos arrays, mas especificando que os números são inteiros, i.e., do tipo int?\n\na = np.zeros(3, dtype=int)\nb = np.ones(3, dtype=int)\n\nprint(a)\nprint(b)\n\n[0 0 0]\n[1 1 1]\n\n\nA função numpy.linspace(x,y,z) nos permite criar um array que vai de x até y, com z elementos igualmente espaçados.\n\na = np.linspace(0,8,5, dtype=int)\n\nprint(a)\n\n[0 2 4 6 8]\n\n\nPodemos acessar os elementos de um array qualquer utilizando a mesma ideia de indexação de listas:\n\nprint('Array a =',a)\nprint('\\nPrimeiro elemento de a = ',a[0])\nprint('Segundo elemento de a = ',a[1])\nprint('Último elemento de a = ',a[-1])\nprint('Dois primeiros elementos de a = ',a[0:2])\n\nArray a = [0 2 4 6 8]\n\nPrimeiro elemento de a =  0\nSegundo elemento de a =  2\nÚltimo elemento de a =  8\nDois primeiros elementos de a =  [0 2]\n\n\n\n\n7.2.2 Arrays multidimensionais\nComo falamos anteriormente, um objeto do tipo numpy.ndarray é um array n-dimensional (por isso o nd em ndarray). Até agora trabalhamos apenas com uma dimensão, mas para as nossas aplicações é particularmente interessante o caso em que o número de dimensões é igual a 2, i.e., para o caso em que o array assume a forma de uma matriz.\nPodemos criar esse tipo de array usando a mesma lógica de antes, com pequenas alterações na sintaxe:\n\nA_22 = np.array([[1, 2], [3, 4]], dtype=int)\n\nprint('Matriz A =\\n',A_22)\n\nMatriz A =\n [[1 2]\n [3 4]]\n\n\nO NumPy nos oferece algumas funções interessantes para criarmos matrizes específicas:\n\nprint('Matriz identidade 2x2 =\\n',np.eye(2,dtype=int))\nprint('\\nMatriz diagonal 3x3 =\\n',np.diag([1,2,3]))\n\nMatriz identidade 2x2 =\n [[1 0]\n [0 1]]\n\nMatriz diagonal 3x3 =\n [[1 0 0]\n [0 2 0]\n [0 0 3]]\n\n\nPodemos criar a matriz transposta de uma dada matriz utilizando a função np.transpose() (ou apenas o método .T):\n\nprint('Matriz A =\\n',A_22)\nprint('\\nTransposta da matriz A =\\n',np.transpose(A_22))\nprint('\\nTransposta da matriz A =\\n',A_22.T)\n\nMatriz A =\n [[1 2]\n [3 4]]\n\nTransposta da matriz A =\n [[1 3]\n [2 4]]\n\nTransposta da matriz A =\n [[1 3]\n [2 4]]\n\n\nAssim como em arrays unidimensionais, podemos acessar os elementos de uma matriz utilizando indexação, mas agora em 2 dimensões:\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\n\nprint('Matriz A =\\n',A)\nprint('\\nElemento 11 de A = ',A[0,0])\nprint('Elemento 23 de A = ',A[1,2])\nprint('Primeira linha de A = ',A[0,:])\nprint('Segunda coluna de A = ',A[:,1])\nprint('\\nSubmatriz de A delimitada pelos elementos 22 e 33 =\\n',A[1:,1:])\n\nMatriz A =\n [[1 2 3]\n [4 5 6]\n [7 8 9]]\n\nElemento 11 de A =  1\nElemento 23 de A =  6\nPrimeira linha de A =  [1 2 3]\nSegunda coluna de A =  [2 5 8]\n\nSubmatriz de A delimitada pelos elementos 22 e 33 =\n [[5 6]\n [8 9]]\n\n\n\n\n7.2.3 Propriedades de arrays\nO NumPy fornece alguns métodos úteis que, apesar de não receberem nenhum argumento, nos permitem acessar algumas das características dos arrays que criamos.\n\nndim retorna o número de dimensões do array;\nshape retorna o tamanho do array em cada uma de suas dimensões;\ndtype retorna o tipo de dado contido no array;\nsize retorna o número total de elementos contidos no array.\n\n\nX1 = np.array([[1,2,3], [4,5,6], [7,8,9]]) \nX2 = X1.flatten() # O método flatten reduz um array de n-dimensões em um array de uma única dimensão\n\nprint('Array X1 =\\n',X1)\nprint('\\nDimensões de X1 = ', X1.ndim)\nprint('Shape de X1 = ', X1.shape)\nprint('Tipo de dado em X1 = ', X1.dtype)\nprint('Número de elementos em X1 = ', X1.size)\n\nprint('\\n\\nArray X2 =\\n',X2)\nprint('\\nDimensões de X2 = ', X2.ndim)\nprint('Shape de X2 = ', X2.shape)\nprint('Tipo de dado em X2 = ', X2.dtype)\nprint('Número de elementos em X2 = ', X2.size)\n\nArray X1 =\n [[1 2 3]\n [4 5 6]\n [7 8 9]]\n\nDimensões de X1 =  2\nShape de X1 =  (3, 3)\nTipo de dado em X1 =  int64\nNúmero de elementos em X1 =  9\n\n\nArray X2 =\n [1 2 3 4 5 6 7 8 9]\n\nDimensões de X2 =  1\nShape de X2 =  (9,)\nTipo de dado em X2 =  int64\nNúmero de elementos em X2 =  9\n\n\nUm método interessante de arrays é o reshape(x,y) que reorganiza um array existente de acordo com os argumentos x e y:\n\nX = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]) \n\nprint('Array X1 4x4 =\\n',X)\nprint('\\n X1 reorganizado em 2x8 =\\n',X.reshape(2,8))\nprint('\\n X1 reorganizado em 8x2 =\\n',X.reshape(8,2))\n\nArray X1 4x4 =\n [[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]\n [13 14 15 16]]\n\n X1 reorganizado em 2x8 =\n [[ 1  2  3  4  5  6  7  8]\n [ 9 10 11 12 13 14 15 16]]\n\n X1 reorganizado em 8x2 =\n [[ 1  2]\n [ 3  4]\n [ 5  6]\n [ 7  8]\n [ 9 10]\n [11 12]\n [13 14]\n [15 16]]",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#operações-básicas-com-arrays",
    "href": "numpy.html#operações-básicas-com-arrays",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "7.3 Operações básicas com arrays",
    "text": "7.3 Operações básicas com arrays\n\n7.3.1 Operações aritméticas simples\nDois tipos de operações que serão úteis para arrays de qualquer dimensão são:\n\nOperações entre um array e um único número.\nOperações entre dois arrays da mesma forma.\n\nQuando realizamos operações em um array usando um único número, simplesmente aplicamos essa operação a cada elemento do array. Isso vale tanto para arrays unidimensionais (vetores) quanto multidimensionais (por ex., matrizes).\n\nx = np.array([1,2,3], dtype=int)\nprint(\"x =\\n\", x)\nprint(\"\\n2 + x =\\n\", 2 + x)\nprint(\"\\n2 - x =\\n\", 2 - x)\nprint(\"\\n2 * x =\\n\", 2 * x)\nprint(\"\\nx / 2 =\\n\", x / 2)\n\nx =\n [1 2 3]\n\n2 + x =\n [3 4 5]\n\n2 - x =\n [ 1  0 -1]\n\n2 * x =\n [2 4 6]\n\nx / 2 =\n [0.5 1.  1.5]\n\n\n\nX = np.ones((2, 2), dtype=int)\n\nprint(\"X =\\n\", X)\nprint(\"\\n2 + X =\\n\", 2 + X)\nprint(\"\\n2 - X =\\n\", 2 - X)\nprint(\"\\n2 * X =\\n\", 2 * X)\nprint(\"\\nX / 2 =\\n\", X / 2)\n\nX =\n [[1 1]\n [1 1]]\n\n2 + X =\n [[3 3]\n [3 3]]\n\n2 - X =\n [[1 1]\n [1 1]]\n\n2 * X =\n [[2 2]\n [2 2]]\n\nX / 2 =\n [[0.5 0.5]\n [0.5 0.5]]\n\n\nPara operações entre dois arrays de mesmo tamanho, basta aplicar a operação elemento a elemento (elementwise, em inglês) entre os arrays.\n\nx = np.array([2, 4, 6], dtype=int)\ny = np.array([2, 2, 1], dtype=int)\n\nprint(\"x =\\n\", x)\nprint(\"\\ny =\\n\", y)\nprint(\"\\nx + y =\\n\", x + y)\nprint(\"\\nx - y =\\n\", x - y)\n\nx =\n [2 4 6]\n\ny =\n [2 2 1]\n\nx + y =\n [4 6 7]\n\nx - y =\n [0 2 5]\n\n\n\nX = np.array([[2, 4], [6, 8]], dtype=int)\nY = np.array([[2, 2], [2, 2]], dtype=int)\n\nprint(\"X =\\n\", X)\nprint(\"\\nY =\\n\", Y)\nprint(\"\\nX + Y =\\n\", X + Y)\nprint(\"\\nX - Y =\\n\", X - Y)\n\nX =\n [[2 4]\n [6 8]]\n\nY =\n [[2 2]\n [2 2]]\n\nX + Y =\n [[ 4  6]\n [ 8 10]]\n\nX - Y =\n [[0 2]\n [4 6]]\n\n\nAs operações de multiplicação e divisão entre arrays são um pouco diferentes. São duas as possibilidades:\n\nMultiplicação e divisão elemento a elemento.\nMultiplicação entre arrays usando a lógica de matriz e “divisão” usando a lógica de matriz inversa.\n\nPara realizar as operações elementwise basta utilizar os sinais usuais de * e /, independentemente do número de dimesões do array.\n\nprint('Vetores x e y:')\nprint('x =',x)\nprint('y =',y)\nprint(\"\\n x * y =\\n\", x * y)\nprint(\"\\n x / y =\\n\", x / y)\n\nprint('\\nMatrizes X e Y:')\nprint('X =\\n',X)\nprint('Y =\\n',Y)\nprint(\"\\n X * Y =\\n\", X * Y)\nprint(\"\\n X / Y =\\n\", X / Y)\n\nVetores x e y:\nx = [2 4 6]\ny = [2 2 1]\n\n x * y =\n [4 8 6]\n\n x / y =\n [1. 2. 6.]\n\nMatrizes X e Y:\nX =\n [[2 4]\n [6 8]]\nY =\n [[2 2]\n [2 2]]\n\n X * Y =\n [[ 4  8]\n [12 16]]\n\n X / Y =\n [[1. 2.]\n [3. 4.]]\n\n\nA multiplicação de matriz com matriz, do jeito que a gente conhece do Ensino Médio é feita usando o símbolo @ (ou através da função np.dot()):\n\nX= np.array([[1, 2], [3, 4]], dtype=int)\nY= np.array([[10, 20], [30, 40]], dtype=int)\n\nprint('X =\\n',X)\nprint('Y =\\n',Y)\nprint('\\nX * Y =\\n', X @ Y)\nprint('\\nX * Y =\\n', np.dot(X,Y))\n\nX =\n [[1 2]\n [3 4]]\nY =\n [[10 20]\n [30 40]]\n\nX * Y =\n [[ 70 100]\n [150 220]]\n\nX * Y =\n [[ 70 100]\n [150 220]]\n\n\nPara calcular a inversa de uma matriz utilizando o NumPy é preciso um pouco mais de estrutura e de conhecimento acerca do subpacote linalg que nos traz funções para realizar operações de álgebra linear. Falaremos disso já já!\n\n\n7.3.2 Funções universais\nAs funções universais no Numpy são funções matemáticas simples. É apenas um termo que demos às funções matemáticas na biblioteca Numpy, que cobrem uma ampla variedade de operações. Essas funções incluem funções trigonométricas padrão, funções para operações aritméticas, manipulação de números complexos, funções estatísticas, etc. Essas funções possuem como características principais:\n\nElas executam operações de array elemento por elemento.\nElas suportam vários recursos, como conversão de tipos.\nAs funções universais são objetos que pertencem à classe numpy.ufunc.\nAs funções do Python também podem ser criadas como uma função universal usando a função da biblioteca frompyfunc.\nAlgumas funções universais são chamadas automaticamente quando o operador aritmético correspondente é usado em arrays. Por exemplo, quando a adição de dois arrays é executada em elementos usando o operador ‘+’, então np.add() é chamado internamente.\n\nDentre as principais funções universais matemáticas estão:\n\nsin, cos, tan: calcular seno, cosseno e tangente de ângulos.\nhypot: calcule a hipotenusa do triângulo retângulo dado.\narcsinh, arcosh, arctanh: calcular seno hiperbólico inverso, cosseno e tangente.\ndeg2rad: converter grau em radianos.\nrad2deg: converter radianos em graus.\n\nDentre as principais funções universais estatísticas estão:\n\namin, amax: retorna o mínimo ou máximo de um array ou ao longo de um eixo.\nptp: retorna o intervalo de valores (máximo-mínimo) de um array ou ao longo de um eixo.\nsum: retorna a soma de valores de um array ao longo de um eixo.\npercentile(a, p, eixo): calcular o p-ésimo percentil da matriz ou ao longo do eixo especificado.\nmedian: calcular a mediana dos dados ao longo do eixo especificado.\nmean: calcular a média dos dados ao longo do eixo especificado.\nvar: calcular a variância de dados ao longo do eixo especificado.\nlog: calcular o log dos dados ao longo do eixo especificado.\n\nAlguns exemplos:\n\nangulos_notaveis_deg = np.array([30,45,60])\nangulos_notaveis_rad = np.deg2rad(angulos_notaveis_deg)\n\nseno_notaveis = [np.round(elem,2) for elem in np.sin(angulos_notaveis_rad)]\ncosseno_notaveis = [np.round(elem,2) for elem in np.cos(angulos_notaveis_rad)]\ntangente_notaveis = [np.round(elem,2) for elem in np.tan(angulos_notaveis_rad)]\n\nprint('Seno, cosseno e tangente de 30 graus: ',seno_notaveis[0],', ',cosseno_notaveis[0],' e ',tangente_notaveis[0])\nprint('Seno, cosseno e tangente de 45 graus: ',seno_notaveis[1],', ',cosseno_notaveis[1],' e ',tangente_notaveis[1])\nprint('Seno, cosseno e tangente de 60 graus: ',seno_notaveis[2],', ',cosseno_notaveis[2],' e ',tangente_notaveis[2])\n\nSeno, cosseno e tangente de 30 graus:  0.5 ,  0.87  e  0.58\nSeno, cosseno e tangente de 45 graus:  0.71 ,  0.71  e  1.0\nSeno, cosseno e tangente de 60 graus:  0.87 ,  0.5  e  1.73\n\n\n\nx = np.array([1,2,3,4,5])\n\nprint('Array x = ',x)\nprint('\\nMínimo de x = ',np.amin(x))\nprint('Máximo de x = ',np.amax(x))\nprint('Intervalo de x = ',np.ptp(x))\nprint('Soma de x = ',np.sum(x))\nprint('Média de x = ',np.mean(x))\nprint('Log de x = ',[np.round(elem,2) for elem in np.log(x)])\n\nArray x =  [1 2 3 4 5]\n\nMínimo de x =  1\nMáximo de x =  5\nIntervalo de x =  4\nSoma de x =  15\nMédia de x =  3.0\nLog de x =  [np.float64(0.0), np.float64(0.69), np.float64(1.1), np.float64(1.39), np.float64(1.61)]\n\n\n\n\n7.3.3 Arrays e listas\nAgora que já vimos um pouco de operações básicas, podemos entender um pouco melhor a diferença de desempenho entre arrays e listas. Considere um array de dez milhões de números inteiros e uma lista equivalente:\n\nmy_array = np.arange(10000000)\nmy_list = list(range(10000000))\n\nAgora vamos multiplicar, elemento a elemento, todos os números por 2 e salvar o resultado correspondente. Utilizaremos a função time do pacote timepara fazer a medição do tempo utilizado pelos dois métodos.\n\nimport time \n\n# arrays\nstart_array = time.time()\nmy_array2 = my_array * 2\nend_array   = time.time()\n\n\n# listas\nstart_lista = time.time()\nmy_list2 = [x * 2 for x in my_list] \nend_lista   = time.time()\n\nratio = (end_lista - start_lista) / (end_array - start_array)\n\nQual abordagem será que levou menos tempo?\n\nprint('Tempo necessário para a realização dos cálculos utilizando arrays: {:.4f} segundos'.format(end_array - start_array))\nprint('Tempo necessário para a realização dos cálculos utilizando listas: {:.4f} segundos'.format(end_lista - start_lista))\nprint('\\nA abordagem de listas demorou {:.0f}x mais tempo! Esqueça listas e use arrays ;)'.format(ratio - 1))\n\nTempo necessário para a realização dos cálculos utilizando arrays: 0.0122 segundos\nTempo necessário para a realização dos cálculos utilizando listas: 0.2895 segundos\n\nA abordagem de listas demorou 23x mais tempo! Esqueça listas e use arrays ;)",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#aplicação-solução-de-sistema-de-equações-lineares",
    "href": "numpy.html#aplicação-solução-de-sistema-de-equações-lineares",
    "title": "7  Arrays, matrizes e álgebra linear",
    "section": "7.4 Aplicação: solução de sistema de equações lineares",
    "text": "7.4 Aplicação: solução de sistema de equações lineares\nChega de exemplos vazios, vamos usar o NumPy para resolver um problema concreto e que nos é muito familiar: a solução de sistemas de equações lineares. Considere o sistema linear de equações dado por\n\\[ A\\cdot \\vec{x} = \\vec{b} \\]\ntal que \\(A\\) é a matriz de coeficientes, \\(\\vec{x}\\) é o vetor de incógnitas e \\(\\vec{b}\\) o vetor de constantes.\n\n7.4.1 Algoritmo de eliminação de Gauss-Jordan\nSegundo Hubbard e Hubbard (2015), uma matriz de coeficientes \\(A\\) é representada em sua forma escalonada reduzida por linhas (reduced row echelon form, em inglês) se\n\nEm toda e qualquer linha, a primeira entrada diferente de zero é igual a 1 (1 pivotal).\nO 1 pivotal de uma linha mais abaixo está sempre à direita de um outro 1 pivotal de alguma linha acima.\nEm toda e qualquer coluna que contém um 1 pivotal, todas as outras entradas são iguais a zero.\nToda linha contendo apenas zeros está no fim da matriz.\n\nÀ partir dessa definição, é possível mostrar que para qualquer matriz \\(A\\), existe uma matriz \\(\\tilde{A}\\) na forma escalonada reduzida por linhas que pode ser obtida à partir de operações elementares nas linhas de A. Além disso, é possível mostrar também que \\(\\tilde{A}\\) é única. Ao algoritmo utilizado para encontrar \\(\\tilde{A}\\) é dado o nome de Algoritmo de Eliminação de Gauss-Jordan.\n\n\nALGORITMO DE ELIMINAÇÃO DE GAUSS-JORDAN\nPara levar uma matriz \\(A\\) a sua forma escalonada reduzida por linhas \\(\\tilde{A}\\) devemos seguir os seguintes passos:\n\n\nEncontre a primeira coluna que não é composta apenas de zeros, chame isso de primeira coluna pivotal e chame sua primeira entrada diferente de zero de pivô. Se o pivô não for na primeira linha, mova a linha que a contém para o topo da matriz.\n\n\n\nDivida a primeira linha inteira pelo pivô, de modo que a primeira entrada da primeira coluna pivotal seja igual a 1.\n\n\n\nAdicione múltiplos apropriados da primeira linha às outras linhas para garantir que todas as outras entradas da primeira coluna pivotal sejam iguais a 0. O 1 na primeira coluna é agora um pivô 1.\n\n\n\nEscolha a próxima coluna que contém pelo menos uma entrada diferente de zero abaixo da primeira linha e coloque a linha que contém o novo pivô na posição da segunda linha. Faça do pivô um pivô 1: divida a linha inteira pelo pivô e adicione múltiplos apropriados desta linha às outras linhas abaixo, para tornar todas as outras entradas desta coluna iguais a 0.\n\n\n\nRepita o processo até que a matriz esteja em sua forma escalonada reduzida por linhas.\n\n\n\nAssuma o caso em que a matriz de coeficiente \\(A\\) e o vetor de constantes \\(b\\) são tais que a matriz ampliada é dada por:\n\\[\\left[\\begin{array}{ccc|c} 2 & 2 & 1 & 1 \\\\ 1 & 3 & 1 & 2 \\\\ 1 & 2 & 2 & -1 \\end{array}\\right] \\]\n\nPasso 1: Defina a matriz M\n\n\nM = np.array([(2, 2, 1, 1),\n              (1, 3, 1, 2),\n              (1, 2, 2, -1)],dtype=float)\nprint('Matriz ampliada =\\n',M)\n\nMatriz ampliada =\n [[ 2.  2.  1.  1.]\n [ 1.  3.  1.  2.]\n [ 1.  2.  2. -1.]]\n\n\n\nPasso 2: Divida a linha 1 pelo primeiro elemento da primeira linha\n\n\nM[0,:] = M[0,:] / M[0,0]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 1.   3.   1.   2. ]\n [ 1.   2.   2.  -1. ]]\n\n\n\nPasso 3: Subtraia a linha 1 da linha 2 e da linha 3\n\n\nM[1,:] = M[1,:] - M[0,:]\nM[2,:] = M[2,:] - M[0,:]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 0.   2.   0.5  1.5]\n [ 0.   1.   1.5 -1.5]]\n\n\n\nPasso 4: Divida a linha 2 pelo segundo elemento da segunda linha\n\n\nM[1,:] = M[1,:] / M[1,1]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    1.    1.5  -1.5 ]]\n\n\n\nPasso 5: Subtraia a linha 2 da linha 3\n\n\nM[2,:] = M[2,:] - M[1,:]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    0.    1.25 -2.25]]\n\n\n\nPasso 6: Divida a linha 3 pelo terceiro elemento da terceira linha\n\n\nM[2,:] = M[2,:] / M[2,2]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    0.    1.   -1.8 ]]\n\n\n\nPasso 7: Multiplique a linha 3 pelo terceiro elemento da segunda linha e subtraia da linha 2\n\n\nM[1,:] = M[1,:] - M[1,2] * M[2,:]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\n\nPasso 8: Multiplique a linha 3 pelo terceiro elemento da primeira linha e subtraia da linha 1\n\n\nM[0,:] = M[0,:] - M[0,2] * M[2,:]\n\nprint(M)\n\n[[ 1.   1.   0.   1.4]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\n\nPasso 9: Subtraia a linha 2 da linha 1\n\n\nM[0,:] = M[0,:] - M[1,:]\n\nprint(M)\n\n[[ 1.   0.   0.   0.2]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\nTemos a nossa matriz em sua forma escalonada reduzida por linhas! A solução do sistema é tal que:\n\nprint('A solução de x1 é: {:.2f}'.format(M[0,3]))\nprint('A solução de x2 é: {:.2f}'.format(M[1,3]))\nprint('A solução de x3 é: {:.2f}'.format(M[2,3]))\n\nA solução de x1 é: 0.20\nA solução de x2 é: 1.20\nA solução de x3 é: -1.80\n\n\nUma forma mais simples de chegar na forma escalonada reduzida por linhas é através do pacote SymPy e das funções Matrix e rref:\n\nimport sympy\n\nM_sympy = sympy.Matrix([(2, 2, 1, 1),\n                        (1, 3, 1, 2),\n                        (1, 2, 2, -1)])\n\nM_sympy.rref()[0]\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & \\frac{1}{5}\\\\0 & 1 & 0 & \\frac{6}{5}\\\\0 & 0 & 1 & - \\frac{9}{5}\\end{matrix}\\right]\\)\n\n\n\n\n7.4.2 Solução de sistemas exatamente identificados\nUma outra forma de resolver sistemas de equações exatamente identificados, quando o número de incógnitas é igual ao número de equações (i.e., matriz \\(A\\) é quadrada) é através da matriz inversa de \\(A\\). Para o caso em que \\(A^{-1}\\) existe, o sistema é tal que\n\\[ \\vec{x} = A^{-1} \\cdot \\vec{b} \\]\nPara que seja possível fazer dessa forma, \\(A\\) deve ser uma matriz quadrada e seu determinante ser diferente de \\(0\\). Mais uma vez assuma o caso em que \\(A\\) e \\(\\vec{b}\\) são dados por:\n\\[A = \\begin{bmatrix} 2 & 2 & 1 \\\\ 1 & 3 & 1 \\\\ 1 & 2 & 2 \\end{bmatrix} \\quad \\quad \\vec{b} = \\begin{bmatrix} 1 \\\\ 2 \\\\ -1 \\end{bmatrix} \\]\nO primeiro passo é conferir se a matrix \\(A\\) é quadrada. Podemos fazer isso usando a função numpy.shape()\n\nb = np.array([1, 2, -1])\nA = np.array([(2, 2, 1), (1, 3, 1), (1, 2, 2)])\n\nnp.shape(A)[0] == np.shape(A)[1]\n\nTrue\n\n\nO próximo passo é ver se o determinante da matriz é igual a 0 e para isso usamos um função do subpacote de álgebra linera do numpy, numpy.linalg.det():\n\nprint('A =')\nprint(A)\n\nprint('\\nDeterminante = ',np.round(np.linalg.det(A)))\n\nA =\n[[2 2 1]\n [1 3 1]\n [1 2 2]]\n\nDeterminante =  5.0\n\n\nComo ambas as condições são satisfeitas, por fim basta calcular a inversa da matriz \\(A\\) com numpy.linalg.inv() e multiplicar por \\(\\vec{b}\\) para chegar nos valores de x, y e z que solucionam o sistema de equações.\n\nprint('A =')\nprint(A)\n\nprint(\"\\nInversa de A = \")\nprint(np.linalg.inv(A))\n\nA =\n[[2 2 1]\n [1 3 1]\n [1 2 2]]\n\nInversa de A = \n[[ 0.8 -0.4 -0.2]\n [-0.2  0.6 -0.2]\n [-0.2 -0.4  0.8]]\n\n\n\nsolution = np.linalg.inv(A) @ b\nsolution\n\narray([ 0.2,  1.2, -1.8])\n\n\n\nprint('A solução de x1 é: {:.2f}'.format(solution[0]))\nprint('A solução de x2 é: {:.2f}'.format(solution[1]))\nprint('A solução de x3 é: {:.2f}'.format(solution[2]))\n\nA solução de x1 é: 0.20\nA solução de x2 é: 1.20\nA solução de x3 é: -1.80\n\n\nUma última alternativa para resolver o sistema \\(A\\cdot \\vec{x} = \\vec{b}\\), é utilizar a função solve do subpacote de álgebra linear do NumPy. Essa função faz o processo de resolução do sistema de forma direta e nos cospe o vetor de resultado.\n\nnp.linalg.solve(A,b)\n\narray([ 0.2,  1.2, -1.8])",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "pandas.html",
    "href": "pandas.html",
    "title": "8  Gestão e análise de dados",
    "section": "",
    "text": "8.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Gestão e análise de dados</span>"
    ]
  },
  {
    "objectID": "visualizacao.html",
    "href": "visualizacao.html",
    "title": "9  Visualização",
    "section": "",
    "text": "9.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Visualização</span>"
    ]
  },
  {
    "objectID": "projeto_empirico.html",
    "href": "projeto_empirico.html",
    "title": "10  Análise empírica integrada",
    "section": "",
    "text": "10.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Análise empírica integrada</span>"
    ]
  },
  {
    "objectID": "complemento.html",
    "href": "complemento.html",
    "title": "Temas complementares",
    "section": "",
    "text": "Este é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Temas complementares"
    ]
  },
  {
    "objectID": "oop.html",
    "href": "oop.html",
    "title": "11  Introdução à programação orientada a objetos (OOP)",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Temas complementares",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introdução à programação orientada a objetos (OOP)</span>"
    ]
  },
  {
    "objectID": "intror.html",
    "href": "intror.html",
    "title": "12  Introdução ao R",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Temas complementares",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  }
]