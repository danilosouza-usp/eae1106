[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EAE1106 - Métodos Computacionais para Economia",
    "section": "",
    "text": "Bem-vindo\nEste é o material da disciplina EAE1106 — Métodos Computacionais para Economia, ministrada no Departamento de Economia da USP.\nO curso tem como objetivo introduzir lógica de programação e análise de dados utilizando principalmente Python, com uma breve introdução a R ao final do semestre.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "index.html#agradecimentos-e-reprodução",
    "href": "index.html#agradecimentos-e-reprodução",
    "title": "EAE1106 - Métodos Computacionais para Economia",
    "section": "Agradecimentos e reprodução",
    "text": "Agradecimentos e reprodução\nEsse material deve muito a X, Y e Z\nEsse material foi construído bla bla bla. Qualquer erro é de responsabilidade exclusiva do autor. Todo e qualquer feedback é muito bem-vindo.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "fundamentos.html",
    "href": "fundamentos.html",
    "title": "1  Fundamentos de computação",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Alfabetização computacional e lógica básica",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentos de computação</span>"
    ]
  },
  {
    "objectID": "numpy.html",
    "href": "numpy.html",
    "title": "2  Arrays, matrizes e álgebra linear",
    "section": "",
    "text": "2.1 O que é o NumPy?\nUma das principais aplicações para o Python bla bla bla\nNumPy (Numerical Python) é o pacote fundamental para computação científica em Python. Essa biblioteca é peça fundamental em outras bibliotecas igualmente importantes, como o Pandas e o Matplotlib. É uma biblioteca Python que tem como principal objeto o ndarray, um array multidimensional que guarda bastante semelhança com a ideia de vetores e matrizes, embora seja um objeto específico dentro da linguagem, com suas características e métodos próprios. O pacote contém também uma variedade de rotinas para operações rápidas em arrays, incluindo matemática, lógica, álgebra linear básica, operações estatísticas básicas e muito mais.\nMas o que é de fato um ndarray? É um objeto multidimensional que nos permite armazenar dados de forma sequencial e que podem ser acessados via indexação. Ué, mas isso é muito parecido com uma lista (ou um conjunto de listas). Qual a diferença então?\nSão muitas as qualidades do NumPy que fazem dele a melhor escolha quanto o assunto é lidar com objetos sequenciais, multidimensionais, e com os quais queremos operar tal qual vetores e matrizes. Mas chega de lenga lenga, vamos ao trabalho!",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#o-que-é-o-numpy",
    "href": "numpy.html#o-que-é-o-numpy",
    "title": "2  Arrays, matrizes e álgebra linear",
    "section": "",
    "text": "NumPy arrays têm um tamanho fixo na criação, ao contrário das listas, que podem crescer. Alterar o tamanho de um ndarray criará um novo array e excluirá o original.\nTodos os elementos em um array devem ser do mesmo tipo de dados, diferentemente de listas, que são objetos mais genéricos. Isso facilita a gestão de memória e torna operações com esse tipo de objeto ordens de magnitude mais rápidas do que se utilizássemos listas.\nA maior velocidade e eficiência de armazenamento fazem do NumPy uma das bibliotecas mais utilizadas em aplicações matemáticas e científicas. Saber apenas as ferramentas nativas do Python, como listas, hoje já não é mais suficiente.",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#elementos-básicos-do-numpy",
    "href": "numpy.html#elementos-básicos-do-numpy",
    "title": "2  Arrays, matrizes e álgebra linear",
    "section": "2.2 Elementos básicos do NumPy",
    "text": "2.2 Elementos básicos do NumPy\nAntes de tudo, é preciso importar o NumPy, já que se trata de uma biblioteca não nativa do Python.\n\nimport numpy as np\n\n\n2.2.1 Arrays unidimensionais\nComecemos criando um numpy.ndarray do zero, contendo os números 1, 2 e 3. Podemos fazê-lo da seguinte forma:\n\na = np.array([1, 2, 3])\nprint(a)\nprint(type(a))\n\n[1 2 3]\n&lt;class 'numpy.ndarray'&gt;\n\n\nA sintaxe é essa mesma: um par de colchetes dentro dos parênteses. Se tentarmos passar sem os colchetes, o Python retornará um erro.\n\na = np.array(1, 2, 3)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 a = np.array(1, 2, 3)\n\nTypeError: array() takes from 1 to 2 positional arguments but 3 were given\n\n\n\nDa mesma forma que uma sequência de 3 números inteiros, podemos criar um numpy.ndarray que repete 3 vezes o número 0 ou 3 vezes o número 1.\n\na = np.zeros(3)\nb = np.ones(3)\n\nprint(a)\nprint(b)\n\n[0. 0. 0.]\n[1. 1. 1.]\n\n\nNote que em ambos os casos os números aparecem com o ponto da casa decimal, o que é um indicativo de que estão armazenados como valores do tipo float. E se quiséssemos criar esses mesmos arrays, mas especificando que os números são inteiros, i.e., do tipo int?\n\na = np.zeros(3, dtype=int)\nb = np.ones(3, dtype=int)\n\nprint(a)\nprint(b)\n\n[0 0 0]\n[1 1 1]\n\n\nA função numpy.linspace(x,y,z) nos permite criar um array que vai de x até y, com z elementos igualmente espaçados.\n\na = np.linspace(0,8,5, dtype=int)\n\nprint(a)\n\n[0 2 4 6 8]\n\n\nPodemos acessar os elementos de um array qualquer utilizando a mesma ideia de indexação de listas:\n\nprint('Array a =',a)\nprint('\\nPrimeiro elemento de a = ',a[0])\nprint('Segundo elemento de a = ',a[1])\nprint('Último elemento de a = ',a[-1])\nprint('Dois primeiros elementos de a = ',a[0:2])\n\nArray a = [0 2 4 6 8]\n\nPrimeiro elemento de a =  0\nSegundo elemento de a =  2\nÚltimo elemento de a =  8\nDois primeiros elementos de a =  [0 2]\n\n\n\n\n2.2.2 Arrays multidimensionais\nComo falamos anteriormente, um objeto do tipo numpy.ndarray é um array n-dimensional (por isso o nd em ndarray). Até agora trabalhamos apenas com uma dimensão, mas para as nossas aplicações é particularmente interessante o caso em que o número de dimensões é igual a 2, i.e., para o caso em que o array assume a forma de uma matriz.\nPodemos criar esse tipo de array usando a mesma lógica de antes, com pequenas alterações na sintaxe:\n\nA_22 = np.array([[1, 2], [3, 4]], dtype=int)\n\nprint('Matriz A =\\n',A_22)\n\nMatriz A =\n [[1 2]\n [3 4]]\n\n\nO NumPy nos oferece algumas funções interessantes para criarmos matrizes específicas:\n\nprint('Matriz identidade 2x2 =\\n',np.eye(2,dtype=int))\nprint('\\nMatriz diagonal 3x3 =\\n',np.diag([1,2,3]))\n\nMatriz identidade 2x2 =\n [[1 0]\n [0 1]]\n\nMatriz diagonal 3x3 =\n [[1 0 0]\n [0 2 0]\n [0 0 3]]\n\n\nPodemos criar a matriz transposta de uma dada matriz utilizando a função np.transpose() (ou apenas o método .T):\n\nprint('Matriz A =\\n',A_22)\nprint('\\nTransposta da matriz A =\\n',np.transpose(A_22))\nprint('\\nTransposta da matriz A =\\n',A_22.T)\n\nMatriz A =\n [[1 2]\n [3 4]]\n\nTransposta da matriz A =\n [[1 3]\n [2 4]]\n\nTransposta da matriz A =\n [[1 3]\n [2 4]]\n\n\nAssim como em arrays unidimensionais, podemos acessar os elementos de uma matriz utilizando indexação, mas agora em 2 dimensões:\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\n\nprint('Matriz A =\\n',A)\nprint('\\nElemento 11 de A = ',A[0,0])\nprint('Elemento 23 de A = ',A[1,2])\nprint('Primeira linha de A = ',A[0,:])\nprint('Segunda coluna de A = ',A[:,1])\nprint('\\nSubmatriz de A delimitada pelos elementos 22 e 33 =\\n',A[1:,1:])\n\nMatriz A =\n [[1 2 3]\n [4 5 6]\n [7 8 9]]\n\nElemento 11 de A =  1\nElemento 23 de A =  6\nPrimeira linha de A =  [1 2 3]\nSegunda coluna de A =  [2 5 8]\n\nSubmatriz de A delimitada pelos elementos 22 e 33 =\n [[5 6]\n [8 9]]\n\n\n\n\n2.2.3 Propriedades de arrays\nO NumPy fornece alguns métodos úteis que, apesar de não receberem nenhum argumento, nos permitem acessar algumas das características dos arrays que criamos.\n\nndim retorna o número de dimensões do array;\nshape retorna o tamanho do array em cada uma de suas dimensões;\ndtype retorna o tipo de dado contido no array;\nsize retorna o número total de elementos contidos no array.\n\n\nX1 = np.array([[1,2,3], [4,5,6], [7,8,9]]) \nX2 = X1.flatten() # O método flatten reduz um array de n-dimensões em um array de uma única dimensão\n\nprint('Array X1 =\\n',X1)\nprint('\\nDimensões de X1 = ', X1.ndim)\nprint('Shape de X1 = ', X1.shape)\nprint('Tipo de dado em X1 = ', X1.dtype)\nprint('Número de elementos em X1 = ', X1.size)\n\nprint('\\n\\nArray X2 =\\n',X2)\nprint('\\nDimensões de X2 = ', X2.ndim)\nprint('Shape de X2 = ', X2.shape)\nprint('Tipo de dado em X2 = ', X2.dtype)\nprint('Número de elementos em X2 = ', X2.size)\n\nArray X1 =\n [[1 2 3]\n [4 5 6]\n [7 8 9]]\n\nDimensões de X1 =  2\nShape de X1 =  (3, 3)\nTipo de dado em X1 =  int64\nNúmero de elementos em X1 =  9\n\n\nArray X2 =\n [1 2 3 4 5 6 7 8 9]\n\nDimensões de X2 =  1\nShape de X2 =  (9,)\nTipo de dado em X2 =  int64\nNúmero de elementos em X2 =  9\n\n\nUm método interessante de arrays é o reshape(x,y) que reorganiza um array existente de acordo com os argumentos x e y:\n\nX = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]) \n\nprint('Array X1 4x4 =\\n',X)\nprint('\\n X1 reorganizado em 2x8 =\\n',X.reshape(2,8))\nprint('\\n X1 reorganizado em 8x2 =\\n',X.reshape(8,2))\n\nArray X1 4x4 =\n [[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]\n [13 14 15 16]]\n\n X1 reorganizado em 2x8 =\n [[ 1  2  3  4  5  6  7  8]\n [ 9 10 11 12 13 14 15 16]]\n\n X1 reorganizado em 8x2 =\n [[ 1  2]\n [ 3  4]\n [ 5  6]\n [ 7  8]\n [ 9 10]\n [11 12]\n [13 14]\n [15 16]]",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#operações-básicas-com-arrays",
    "href": "numpy.html#operações-básicas-com-arrays",
    "title": "2  Arrays, matrizes e álgebra linear",
    "section": "2.3 Operações básicas com arrays",
    "text": "2.3 Operações básicas com arrays\n\n2.3.1 Operações aritméticas simples\nDois tipos de operações que serão úteis para arrays de qualquer dimensão são:\n\nOperações entre um array e um único número.\nOperações entre dois arrays da mesma forma.\n\nQuando realizamos operações em um array usando um único número, simplesmente aplicamos essa operação a cada elemento do array. Isso vale tanto para arrays unidimensionais (vetores) quanto multidimensionais (por ex., matrizes).\n\nx = np.array([1,2,3], dtype=int)\nprint(\"x =\\n\", x)\nprint(\"\\n2 + x =\\n\", 2 + x)\nprint(\"\\n2 - x =\\n\", 2 - x)\nprint(\"\\n2 * x =\\n\", 2 * x)\nprint(\"\\nx / 2 =\\n\", x / 2)\n\nx =\n [1 2 3]\n\n2 + x =\n [3 4 5]\n\n2 - x =\n [ 1  0 -1]\n\n2 * x =\n [2 4 6]\n\nx / 2 =\n [0.5 1.  1.5]\n\n\n\nX = np.ones((2, 2), dtype=int)\n\nprint(\"X =\\n\", X)\nprint(\"\\n2 + X =\\n\", 2 + X)\nprint(\"\\n2 - X =\\n\", 2 - X)\nprint(\"\\n2 * X =\\n\", 2 * X)\nprint(\"\\nX / 2 =\\n\", X / 2)\n\nX =\n [[1 1]\n [1 1]]\n\n2 + X =\n [[3 3]\n [3 3]]\n\n2 - X =\n [[1 1]\n [1 1]]\n\n2 * X =\n [[2 2]\n [2 2]]\n\nX / 2 =\n [[0.5 0.5]\n [0.5 0.5]]\n\n\nPara operações entre dois arrays de mesmo tamanho, basta aplicar a operação elemento a elemento (elementwise, em inglês) entre os arrays.\n\nx = np.array([2, 4, 6], dtype=int)\ny = np.array([2, 2, 1], dtype=int)\n\nprint(\"x =\\n\", x)\nprint(\"\\ny =\\n\", y)\nprint(\"\\nx + y =\\n\", x + y)\nprint(\"\\nx - y =\\n\", x - y)\n\nx =\n [2 4 6]\n\ny =\n [2 2 1]\n\nx + y =\n [4 6 7]\n\nx - y =\n [0 2 5]\n\n\n\nX = np.array([[2, 4], [6, 8]], dtype=int)\nY = np.array([[2, 2], [2, 2]], dtype=int)\n\nprint(\"X =\\n\", X)\nprint(\"\\nY =\\n\", Y)\nprint(\"\\nX + Y =\\n\", X + Y)\nprint(\"\\nX - Y =\\n\", X - Y)\n\nX =\n [[2 4]\n [6 8]]\n\nY =\n [[2 2]\n [2 2]]\n\nX + Y =\n [[ 4  6]\n [ 8 10]]\n\nX - Y =\n [[0 2]\n [4 6]]\n\n\nAs operações de multiplicação e divisão entre arrays são um pouco diferentes. São duas as possibilidades:\n\nMultiplicação e divisão elemento a elemento.\nMultiplicação entre arrays usando a lógica de matriz e “divisão” usando a lógica de matriz inversa.\n\nPara realizar as operações elementwise basta utilizar os sinais usuais de * e /, independentemente do número de dimesões do array.\n\nprint('Vetores x e y:')\nprint('x =',x)\nprint('y =',y)\nprint(\"\\n x * y =\\n\", x * y)\nprint(\"\\n x / y =\\n\", x / y)\n\nprint('\\nMatrizes X e Y:')\nprint('X =\\n',X)\nprint('Y =\\n',Y)\nprint(\"\\n X * Y =\\n\", X * Y)\nprint(\"\\n X / Y =\\n\", X / Y)\n\nVetores x e y:\nx = [2 4 6]\ny = [2 2 1]\n\n x * y =\n [4 8 6]\n\n x / y =\n [1. 2. 6.]\n\nMatrizes X e Y:\nX =\n [[2 4]\n [6 8]]\nY =\n [[2 2]\n [2 2]]\n\n X * Y =\n [[ 4  8]\n [12 16]]\n\n X / Y =\n [[1. 2.]\n [3. 4.]]\n\n\nA multiplicação de matriz com matriz, do jeito que a gente conhece do Ensino Médio é feita usando o símbolo @ (ou através da função np.dot()):\n\nX= np.array([[1, 2], [3, 4]], dtype=int)\nY= np.array([[10, 20], [30, 40]], dtype=int)\n\nprint('X =\\n',X)\nprint('Y =\\n',Y)\nprint('\\nX * Y =\\n', X @ Y)\nprint('\\nX * Y =\\n', np.dot(X,Y))\n\nX =\n [[1 2]\n [3 4]]\nY =\n [[10 20]\n [30 40]]\n\nX * Y =\n [[ 70 100]\n [150 220]]\n\nX * Y =\n [[ 70 100]\n [150 220]]\n\n\nPara calcular a inversa de uma matriz utilizando o NumPy é preciso um pouco mais de estrutura e de conhecimento acerca do subpacote linalg que nos traz funções para realizar operações de álgebra linear. Falaremos disso já já!\n\n\n2.3.2 Funções universais\nAs funções universais no Numpy são funções matemáticas simples. É apenas um termo que demos às funções matemáticas na biblioteca Numpy, que cobrem uma ampla variedade de operações. Essas funções incluem funções trigonométricas padrão, funções para operações aritméticas, manipulação de números complexos, funções estatísticas, etc. Essas funções possuem como características principais:\n\nElas executam operações de array elemento por elemento.\nElas suportam vários recursos, como conversão de tipos.\nAs funções universais são objetos que pertencem à classe numpy.ufunc.\nAs funções do Python também podem ser criadas como uma função universal usando a função da biblioteca frompyfunc.\nAlgumas funções universais são chamadas automaticamente quando o operador aritmético correspondente é usado em arrays. Por exemplo, quando a adição de dois arrays é executada em elementos usando o operador ‘+’, então np.add() é chamado internamente.\n\nDentre as principais funções universais matemáticas estão:\n\nsin, cos, tan: calcular seno, cosseno e tangente de ângulos.\nhypot: calcule a hipotenusa do triângulo retângulo dado.\narcsinh, arcosh, arctanh: calcular seno hiperbólico inverso, cosseno e tangente.\ndeg2rad: converter grau em radianos.\nrad2deg: converter radianos em graus.\n\nDentre as principais funções universais estatísticas estão:\n\namin, amax: retorna o mínimo ou máximo de um array ou ao longo de um eixo.\nptp: retorna o intervalo de valores (máximo-mínimo) de um array ou ao longo de um eixo.\nsum: retorna a soma de valores de um array ao longo de um eixo.\npercentile(a, p, eixo): calcular o p-ésimo percentil da matriz ou ao longo do eixo especificado.\nmedian: calcular a mediana dos dados ao longo do eixo especificado.\nmean: calcular a média dos dados ao longo do eixo especificado.\nvar: calcular a variância de dados ao longo do eixo especificado.\nlog: calcular o log dos dados ao longo do eixo especificado.\n\nAlguns exemplos:\n\nangulos_notaveis_deg = np.array([30,45,60])\nangulos_notaveis_rad = np.deg2rad(angulos_notaveis_deg)\n\nseno_notaveis = [np.round(elem,2) for elem in np.sin(angulos_notaveis_rad)]\ncosseno_notaveis = [np.round(elem,2) for elem in np.cos(angulos_notaveis_rad)]\ntangente_notaveis = [np.round(elem,2) for elem in np.tan(angulos_notaveis_rad)]\n\nprint('Seno, cosseno e tangente de 30 graus: ',seno_notaveis[0],', ',cosseno_notaveis[0],' e ',tangente_notaveis[0])\nprint('Seno, cosseno e tangente de 45 graus: ',seno_notaveis[1],', ',cosseno_notaveis[1],' e ',tangente_notaveis[1])\nprint('Seno, cosseno e tangente de 60 graus: ',seno_notaveis[2],', ',cosseno_notaveis[2],' e ',tangente_notaveis[2])\n\nSeno, cosseno e tangente de 30 graus:  0.5 ,  0.87  e  0.58\nSeno, cosseno e tangente de 45 graus:  0.71 ,  0.71  e  1.0\nSeno, cosseno e tangente de 60 graus:  0.87 ,  0.5  e  1.73\n\n\n\nx = np.array([1,2,3,4,5])\n\nprint('Array x = ',x)\nprint('\\nMínimo de x = ',np.amin(x))\nprint('Máximo de x = ',np.amax(x))\nprint('Intervalo de x = ',np.ptp(x))\nprint('Soma de x = ',np.sum(x))\nprint('Média de x = ',np.mean(x))\nprint('Log de x = ',[np.round(elem,2) for elem in np.log(x)])\n\nArray x =  [1 2 3 4 5]\n\nMínimo de x =  1\nMáximo de x =  5\nIntervalo de x =  4\nSoma de x =  15\nMédia de x =  3.0\nLog de x =  [np.float64(0.0), np.float64(0.69), np.float64(1.1), np.float64(1.39), np.float64(1.61)]\n\n\n\n\n2.3.3 Arrays e listas\nAgora que já vimos um pouco de operações básicas, podemos entender um pouco melhor a diferença de desempenho entre arrays e listas. Considere um array de dez milhões de números inteiros e uma lista equivalente:\n\nmy_array = np.arange(10000000)\nmy_list = list(range(10000000))\n\nAgora vamos multiplicar, elemento a elemento, todos os números por 2 e salvar o resultado correspondente. Utilizaremos a função time do pacote timepara fazer a medição do tempo utilizado pelos dois métodos.\n\nimport time \n\n# arrays\nstart_array = time.time()\nmy_array2 = my_array * 2\nend_array   = time.time()\n\n\n# listas\nstart_lista = time.time()\nmy_list2 = [x * 2 for x in my_list] \nend_lista   = time.time()\n\nratio = (end_lista - start_lista) / (end_array - start_array)\n\nQual abordagem será que levou menos tempo?\n\nprint('Tempo necessário para a realização dos cálculos utilizando arrays: {:.4f} segundos'.format(end_array - start_array))\nprint('Tempo necessário para a realização dos cálculos utilizando listas: {:.4f} segundos'.format(end_lista - start_lista))\nprint('\\nA abordagem de listas demorou {:.0f}x mais tempo! Esqueça listas e use arrays ;)'.format(ratio - 1))\n\nTempo necessário para a realização dos cálculos utilizando arrays: 0.0130 segundos\nTempo necessário para a realização dos cálculos utilizando listas: 0.2902 segundos\n\nA abordagem de listas demorou 21x mais tempo! Esqueça listas e use arrays ;)",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "numpy.html#aplicação-solução-de-sistema-de-equações-lineares",
    "href": "numpy.html#aplicação-solução-de-sistema-de-equações-lineares",
    "title": "2  Arrays, matrizes e álgebra linear",
    "section": "2.4 Aplicação: solução de sistema de equações lineares",
    "text": "2.4 Aplicação: solução de sistema de equações lineares\nChega de exemplos vazios, vamos usar o NumPy para resolver um problema concreto e que nos é muito familiar: a solução de sistemas de equações lineares. Considere o sistema linear de equações dado por\n\\[ A\\cdot \\vec{x} = \\vec{b} \\]\ntal que \\(A\\) é a matriz de coeficientes, \\(\\vec{x}\\) é o vetor de incógnitas e \\(\\vec{b}\\) o vetor de constantes.\n\n2.4.1 Algoritmo de eliminação de Gauss-Jordan\nSegundo Hubbard e Hubbard (2015), uma matriz de coeficientes \\(A\\) é representada em sua forma escalonada reduzida por linhas (reduced row echelon form, em inglês) se\n\nEm toda e qualquer linha, a primeira entrada diferente de zero é igual a 1 (1 pivotal).\nO 1 pivotal de uma linha mais abaixo está sempre à direita de um outro 1 pivotal de alguma linha acima.\nEm toda e qualquer coluna que contém um 1 pivotal, todas as outras entradas são iguais a zero.\nToda linha contendo apenas zeros está no fim da matriz.\n\nÀ partir dessa definição, é possível mostrar que para qualquer matriz \\(A\\), existe uma matriz \\(\\tilde{A}\\) na forma escalonada reduzida por linhas que pode ser obtida à partir de operações elementares nas linhas de A. Além disso, é possível mostrar também que \\(\\tilde{A}\\) é única. Ao algoritmo utilizado para encontrar \\(\\tilde{A}\\) é dado o nome de Algoritmo de Eliminação de Gauss-Jordan.\n\n\nALGORITMO DE ELIMINAÇÃO DE GAUSS-JORDAN\nPara levar uma matriz \\(A\\) a sua forma escalonada reduzida por linhas \\(\\tilde{A}\\) devemos seguir os seguintes passos:\n\n\nEncontre a primeira coluna que não é composta apenas de zeros, chame isso de primeira coluna pivotal e chame sua primeira entrada diferente de zero de pivô. Se o pivô não for na primeira linha, mova a linha que a contém para o topo da matriz.\n\n\n\nDivida a primeira linha inteira pelo pivô, de modo que a primeira entrada da primeira coluna pivotal seja igual a 1.\n\n\n\nAdicione múltiplos apropriados da primeira linha às outras linhas para garantir que todas as outras entradas da primeira coluna pivotal sejam iguais a 0. O 1 na primeira coluna é agora um pivô 1.\n\n\n\nEscolha a próxima coluna que contém pelo menos uma entrada diferente de zero abaixo da primeira linha e coloque a linha que contém o novo pivô na posição da segunda linha. Faça do pivô um pivô 1: divida a linha inteira pelo pivô e adicione múltiplos apropriados desta linha às outras linhas abaixo, para tornar todas as outras entradas desta coluna iguais a 0.\n\n\n\nRepita o processo até que a matriz esteja em sua forma escalonada reduzida por linhas.\n\n\n\nAssuma o caso em que a matriz de coeficiente \\(A\\) e o vetor de constantes \\(b\\) são tais que a matriz ampliada é dada por:\n\\[\\left[\\begin{array}{ccc|c} 2 & 2 & 1 & 1 \\\\ 1 & 3 & 1 & 2 \\\\ 1 & 2 & 2 & -1 \\end{array}\\right] \\]\n\nPasso 1: Defina a matriz M\n\n\nM = np.array([(2, 2, 1, 1),\n              (1, 3, 1, 2),\n              (1, 2, 2, -1)],dtype=float)\nprint('Matriz ampliada =\\n',M)\n\nMatriz ampliada =\n [[ 2.  2.  1.  1.]\n [ 1.  3.  1.  2.]\n [ 1.  2.  2. -1.]]\n\n\n\nPasso 2: Divida a linha 1 pelo primeiro elemento da primeira linha\n\n\nM[0,:] = M[0,:] / M[0,0]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 1.   3.   1.   2. ]\n [ 1.   2.   2.  -1. ]]\n\n\n\nPasso 3: Subtraia a linha 1 da linha 2 e da linha 3\n\n\nM[1,:] = M[1,:] - M[0,:]\nM[2,:] = M[2,:] - M[0,:]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 0.   2.   0.5  1.5]\n [ 0.   1.   1.5 -1.5]]\n\n\n\nPasso 4: Divida a linha 2 pelo segundo elemento da segunda linha\n\n\nM[1,:] = M[1,:] / M[1,1]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    1.    1.5  -1.5 ]]\n\n\n\nPasso 5: Subtraia a linha 2 da linha 3\n\n\nM[2,:] = M[2,:] - M[1,:]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    0.    1.25 -2.25]]\n\n\n\nPasso 6: Divida a linha 3 pelo terceiro elemento da terceira linha\n\n\nM[2,:] = M[2,:] / M[2,2]\n\nprint(M)\n\n[[ 1.    1.    0.5   0.5 ]\n [ 0.    1.    0.25  0.75]\n [ 0.    0.    1.   -1.8 ]]\n\n\n\nPasso 7: Multiplique a linha 3 pelo terceiro elemento da segunda linha e subtraia da linha 2\n\n\nM[1,:] = M[1,:] - M[1,2] * M[2,:]\n\nprint(M)\n\n[[ 1.   1.   0.5  0.5]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\n\nPasso 8: Multiplique a linha 3 pelo terceiro elemento da primeira linha e subtraia da linha 1\n\n\nM[0,:] = M[0,:] - M[0,2] * M[2,:]\n\nprint(M)\n\n[[ 1.   1.   0.   1.4]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\n\nPasso 9: Subtraia a linha 2 da linha 1\n\n\nM[0,:] = M[0,:] - M[1,:]\n\nprint(M)\n\n[[ 1.   0.   0.   0.2]\n [ 0.   1.   0.   1.2]\n [ 0.   0.   1.  -1.8]]\n\n\nTemos a nossa matriz em sua forma escalonada reduzida por linhas! A solução do sistema é tal que:\n\nprint('A solução de x1 é: {:.2f}'.format(M[0,3]))\nprint('A solução de x2 é: {:.2f}'.format(M[1,3]))\nprint('A solução de x3 é: {:.2f}'.format(M[2,3]))\n\nA solução de x1 é: 0.20\nA solução de x2 é: 1.20\nA solução de x3 é: -1.80\n\n\nUma forma mais simples de chegar na forma escalonada reduzida por linhas é através do pacote SymPy e das funções Matrix e rref:\n\nimport sympy\n\nM_sympy = sympy.Matrix([(2, 2, 1, 1),\n                        (1, 3, 1, 2),\n                        (1, 2, 2, -1)])\n\nM_sympy.rref()[0]\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & \\frac{1}{5}\\\\0 & 1 & 0 & \\frac{6}{5}\\\\0 & 0 & 1 & - \\frac{9}{5}\\end{matrix}\\right]\\)\n\n\n\n\n2.4.2 Solução de sistemas exatamente identificados\nUma outra forma de resolver sistemas de equações exatamente identificados, quando o número de incógnitas é igual ao número de equações (i.e., matriz \\(A\\) é quadrada) é através da matriz inversa de \\(A\\). Para o caso em que \\(A^{-1}\\) existe, o sistema é tal que\n\\[ \\vec{x} = A^{-1} \\cdot \\vec{b} \\]\nPara que seja possível fazer dessa forma, \\(A\\) deve ser uma matriz quadrada e seu determinante ser diferente de \\(0\\). Mais uma vez assuma o caso em que \\(A\\) e \\(\\vec{b}\\) são dados por:\n\\[A = \\begin{bmatrix} 2 & 2 & 1 \\\\ 1 & 3 & 1 \\\\ 1 & 2 & 2 \\end{bmatrix} \\quad \\quad \\vec{b} = \\begin{bmatrix} 1 \\\\ 2 \\\\ -1 \\end{bmatrix} \\]\nO primeiro passo é conferir se a matrix \\(A\\) é quadrada. Podemos fazer isso usando a função numpy.shape()\n\nb = np.array([1, 2, -1])\nA = np.array([(2, 2, 1), (1, 3, 1), (1, 2, 2)])\n\nnp.shape(A)[0] == np.shape(A)[1]\n\nTrue\n\n\nO próximo passo é ver se o determinante da matriz é igual a 0 e para isso usamos um função do subpacote de álgebra linera do numpy, numpy.linalg.det():\n\nprint('A =')\nprint(A)\n\nprint('\\nDeterminante = ',np.round(np.linalg.det(A)))\n\nA =\n[[2 2 1]\n [1 3 1]\n [1 2 2]]\n\nDeterminante =  5.0\n\n\nComo ambas as condições são satisfeitas, por fim basta calcular a inversa da matriz \\(A\\) com numpy.linalg.inv() e multiplicar por \\(\\vec{b}\\) para chegar nos valores de x, y e z que solucionam o sistema de equações.\n\nprint('A =')\nprint(A)\n\nprint(\"\\nInversa de A = \")\nprint(np.linalg.inv(A))\n\nA =\n[[2 2 1]\n [1 3 1]\n [1 2 2]]\n\nInversa de A = \n[[ 0.8 -0.4 -0.2]\n [-0.2  0.6 -0.2]\n [-0.2 -0.4  0.8]]\n\n\n\nsolution = np.linalg.inv(A) @ b\nsolution\n\narray([ 0.2,  1.2, -1.8])\n\n\n\nprint('A solução de x1 é: {:.2f}'.format(solution[0]))\nprint('A solução de x2 é: {:.2f}'.format(solution[1]))\nprint('A solução de x3 é: {:.2f}'.format(solution[2]))\n\nA solução de x1 é: 0.20\nA solução de x2 é: 1.20\nA solução de x3 é: -1.80\n\n\nUma última alternativa para resolver o sistema \\(A\\cdot \\vec{x} = \\vec{b}\\), é utilizar a função solve do subpacote de álgebra linear do NumPy. Essa função faz o processo de resolução do sistema de forma direta e nos cospe o vetor de resultado.\n\nnp.linalg.solve(A,b)\n\narray([ 0.2,  1.2, -1.8])",
    "crumbs": [
      "Computação numérica, análise de dados e visualização",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arrays, matrizes e álgebra linear</span>"
    ]
  },
  {
    "objectID": "oop.html",
    "href": "oop.html",
    "title": "3  Introdução à programação orientada a objetos (OOP)",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Temas complementares",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução à programação orientada a objetos (OOP)</span>"
    ]
  },
  {
    "objectID": "intror.html",
    "href": "intror.html",
    "title": "4  Introdução ao R",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "Temas complementares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  }
]